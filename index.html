<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kickcoins - Fantasy Betting</title>
<style>
/* ========== THEME ==========
   - Purely visual changes (no structural/JS changes)
   - Uses CSS variables for easy tweaks
================================ */
:root{
  --bg: #0f1115;
  --panel: #171a21;
  --panel-2: #1b1f27;
  --ink: #e8eef7;
  --ink-dim: #b9c2d3;
  --accent: #00ffa3;
  --accent-2: #39c6ff;
  --red: #ff4d4d;
  --warning: #ffc46b;
  --divider: #262b36;
  --muted: #8c95a6;
  --shadow: 0 10px 24px rgba(0,0,0,.35), 0 2px 6px rgba(0,0,0,.25);
  --radius: 12px;
}

/* ===== Base ===== */
*{ box-sizing: border-box; }
html,body{ height:100%; }
body{
  font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  background: radial-gradient(1200px 800px at 120% -10%, rgba(0,255,163,.06), transparent 60%),
              radial-gradient(1200px 900px at -20% 120%, rgba(57,198,255,.05), transparent 60%),
              var(--bg);
  color: var(--ink);
  margin:0;
  padding:0;
  line-height:1.45;
}

/* ===== Header ===== */
header{
  display:flex; justify-content:space-between; align-items:center;
  padding:14px 20px;
  background: linear-gradient(180deg,#12151b, #0f1218);
  border-bottom: 1px solid var(--divider);
  position: sticky; top:0; z-index:60;
}
header h1{
  margin:0; font-size:20px; letter-spacing:.3px; font-weight:700;
  display:flex; align-items:center; gap:10px;
}
header h1::after{
  content:""; width:8px; height:8px; border-radius:50%;
  background: radial-gradient(circle at 30% 30%, white 0 20%, var(--accent) 20% 100%);
  filter: blur(.2px);
}
header .account{ display:flex; align-items:center; gap:14px; color:var(--ink-dim); font-weight:600; }
#logout-btn{
  background: transparent; border:1px solid var(--divider); color:var(--ink);
  padding:6px 10px; border-radius:8px; cursor:pointer;
}
#logout-btn:hover{ border-color: var(--ink-dim); }

/* ===== Tabs ===== */
.tabs{
  display:flex; background: #0f1218; border-bottom:1px solid var(--divider);
  position: sticky; top:54px; z-index:55;
}
.tab{
  flex:1; padding:12px; text-align:center; cursor:pointer; user-select:none;
  color:var(--muted); font-weight:700; letter-spacing:.2px;
  border-bottom:2px solid transparent;
  transition: all .2s ease;
}
.tab:hover{ color:var(--ink); background: rgba(255,255,255,.02); }
.tab.active{
  color:var(--ink);
  border-bottom-color: var(--accent);
  background:
    radial-gradient(600px 120px at 50% 110%, rgba(0,255,163,.08), transparent 60%);
}

/* ===== Main / Cards ===== */
main{ padding: 22px; max-width: 1000px; margin: 0 auto; }
.card{
  background: linear-gradient(180deg, var(--panel), var(--panel-2));
  padding:18px; margin:14px 0; border-radius: var(--radius);
  border: 1px solid var(--divider);
  box-shadow: var(--shadow);
}
.card h2{ margin: 0 0 10px; font-size: 18px; letter-spacing:.3px; }
h4{ margin: 6px 0 8px; color: var(--ink-dim); }

/* ===== Inputs & Buttons ===== */
label{ color: var(--ink-dim); margin-right:8px; }
input[type="text"], input[type="number"], select{
  background:#0f131a; color:var(--ink); border:1px solid #242a36;
  padding:8px 10px; border-radius:10px; outline:none;
  transition: border-color .2s ease, box-shadow .2s ease;
}
input[type="text"]:focus, input[type="number"]:focus, select:focus{
  border-color: var(--accent);
  box-shadow: 0 0 0 3px rgba(0,255,163,.12);
}

button{
  padding:10px 14px; cursor:pointer; border:none; border-radius:10px;
  background: linear-gradient(180deg, #1f2530, #191e26);
  color: var(--ink); font-weight:800; letter-spacing:.3px;
  border:1px solid #2a3240; transition: transform .04s ease, border-color .2s ease, background .2s ease;
}
button:hover{ border-color: var(--accent); }
button:active{ transform: translateY(1px); }
button:disabled{
  background: #141820; border-color: #1f2530; color:#6e7788; cursor:not-allowed;
}

.green{ color: var(--accent); }
.red{ color: var(--red); }
.bet-payout{ margin-left: 10px; font-weight:800; }

/* ===== Props list row ===== */
.prop{
  display:flex; justify-content:space-between; align-items:center;
  margin:10px 0; padding:10px 12px; border-radius:10px;
  background:#121722; border:1px solid #202636;
}
.prop span{ font-weight:700; }

/* ===== Tables ===== */
table{ width:100%; border-collapse: collapse; overflow:hidden; border-radius: 12px; }
thead th{
  background:#121722; color:var(--ink-dim); font-weight:700; letter-spacing:.2px;
  border-bottom:1px solid var(--divider); padding:10px;
}
tbody td{
  padding:10px; border-bottom:1px solid #1e2431;
}
tbody tr:hover{ background:#0f141e; }

/* ===== Match / MVP cards in history ===== */
.match-card, .mvp-card{
  background: linear-gradient(180deg, #171c26, #151a22);
  border:1px solid #242b37; border-radius: 12px; padding: 12px 14px; margin-bottom: 14px;
}
.match-card strong, .mvp-card strong{ display:block; margin-bottom:8px; font-size: 16px; }
.match-card ul{ padding-left:20px; margin:0; }
.match-card .total{
  font-weight:800; background: #11161f; padding:6px 10px; border-radius:8px; margin-top:8px;
}

/* ===== Admin resolve buttons ===== */
.admin-bet-card{
  margin:10px 0; padding:12px; background:#11161f; border-radius: 10px; border:1px solid #202636;
}
.admin-win-btn{
  background: linear-gradient(180deg, #00ffa3, #00cf87);
  color:#001a12; border:none; padding:8px 12px; border-radius:10px; font-weight:900; margin-right:10px;
}
.admin-lose-btn{
  background: linear-gradient(180deg, #ff6666, #e84b4b);
  color:#1a0000; border:none; padding:8px 12px; border-radius:10px; font-weight:900;
}

/* ===== Admin sections ===== */
.admin-section{
  background: linear-gradient(180deg, #151a22, #131821);
  border-radius: 12px; padding: 15px; margin-bottom: 20px; border:1px solid #232a38;
}
.admin-section h3{ margin:0 0 10px; font-size:18px; color: var(--ink); }

.tag-list{ display:flex; flex-wrap:wrap; gap:8px; }
.tag{
  background:#11161f; padding:6px 10px; border-radius: 20px; color:#e6eefc; font-size:14px;
  display:flex; align-items:center; border:1px solid #223048;
}
.tag button{
  margin-left:8px; background:#2a394f; border:none; border-radius:50%;
  width:20px; height:20px; font-size:12px; cursor:pointer; color:white;
}
.tag button:hover{ background:#364a68; }

/* ===== Status Bar ===== */
#status-bar{
  display:none; position: sticky; top: 54px; z-index: 58;
  background: #111; border-top: 1px solid #333; border-bottom: 1px solid #333;
  padding: 12px 16px; font-weight: 800; letter-spacing:.2px; text-align:center;
  box-shadow: var(--shadow);
  border-radius: 0 0 12px 12px;
}
#status-bar.open      { background:#0f1f0f; color:#98ffa1; border-color:#1f5f1f; }
#status-bar.closed    { background:#141414; color:#bbb;    border-color:#333;    }
#status-bar.started   { background:#0f1626; color:#9ecbff; border-color:#294a7a; }
#status-bar.ended     { background:#1f1010; color:#ffb4b4; border-color:#6a2323; }
#status-bar.pulse{
  box-shadow: 0 0 0 0 rgba(0,255,163,.7);
  animation: pulseGlow 1.6s ease-out infinite;
}
@keyframes pulseGlow{
  0%   { box-shadow: 0 0 0 0 rgba(0,255,163,.6); }
  70%  { box-shadow: 0 0 0 16px rgba(0,255,163,0); }
  100% { box-shadow: 0 0 0 0 rgba(0,255,163,0); }
}

/* ===== Login card ===== */
#login-card{ max-width:420px; margin: 60px auto; padding: 22px; }

/* ===== Responsive tweaks ===== */
@media (max-width: 720px){
  main{ padding:14px; }
  .tabs{ top: 52px; }
  header{ padding:12px 14px; }
  #status-bar{ top: 50px; padding: 10px 12px; font-size: 14px; }
  .admin-section{ padding:12px; }
  button{ padding:9px 12px; }
  input, select{ width: 100%; margin: 6px 0; }
  .prop{ flex-direction: column; align-items: flex-start; gap:8px; }
}

/* Keep any legacy classes working */
.total-coins{
  font-weight:800; background:#11161f; padding:6px 10px; border-radius:8px; margin-top:8px;
}
</style>
<!-- Firebase (compat build for Auth) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
</head>
<body>

<header>
<h1>Kickcoins ‚öΩ</h1>
<div class="account" id="account-info"></div>
<button id="logout-btn" style="display:none;">Logout</button>
</header>
<div id="status-bar"></div>

<div id="login-card" class="card">
<h2>Login / Create Account</h2>
<label>Username:</label><input type="text" id="login-username"><br><br>
<label>Password:</label><input type="password" id="login-password"><br><br>
<button id="login-btn">Login</button>
<button id="create-btn">Create Account</button>
</div>

<div id="app" style="display:none;">
<div class="tabs">
    <div class="tab active" data-tab="vote">MVP Voting</div>
    <div class="tab" data-tab="bet">Betting</div>
    <div class="tab" data-tab="leaderboard">Leaderboards</div>
    <div class="tab" data-tab="history">Bet History</div>
    <div class="tab" data-tab="admin">Admin</div>
</div>

<main>
<!-- MVP Voting -->
<div class="tab-content" id="vote-tab">
    <div class="card">
        <h2>Vote for MVP</h2>
        <label>1st Place:</label>
        <select id="vote1"></select>
        <label>2nd Place:</label>
        <select id="vote2"></select>
        <label>3rd Place:</label>
        <select id="vote3"></select>
        <button id="submit-votes">Submit Votes</button>
    </div>
</div>

<!-- Betting -->
<div class="tab-content" id="bet-tab" style="display:none;">
    <div class="card">
        <h2>Betting</h2>
        <div id="balance-display"></div>
        <label>Select Player:</label>
        <select id="player-select"></select>
        <div id="props-container"></div>
        <div>Total Potential Payout: <span id="total-payout" class="bet-payout">0</span></div>
        <button id="submit-bets">Place Bets</button>
    </div>
</div>

<!-- Leaderboards -->
<div class="tab-content" id="leaderboard-tab" style="display:none;">
    <div class="card">
        <h2>Overall MVP Leaderboard</h2>
        <table id="mvp-leaderboard">
            <thead><tr><th>Place</th><th>Player</th><th>Points</th></tr></thead>
            <tbody></tbody>
        </table>
    </div>
    <div class="card">
        <h2>MVP History per Match</h2>
        <div id="mvp-history"></div>
    </div>
</div>

<!-- Bet History -->
<div class="tab-content" id="history-tab" style="display:none;">
    <div class="card">
        <h2>Betting Leaderboard</h2>
        <table id="coin-leaderboard">
            <thead><tr><th>Place</th><th>Player</th><th>Coins</th><th>Admin</th></tr></thead>
            <tbody></tbody>
        </table>
    </div>
    <div class="card" id="history-container"></div>
</div>

<!-- Admin -->
<div class="tab-content" id="admin-tab" style="display:none;">
    <div class="card">
        <h2>Admin Controls</h2>
        <button id="open-bets">Open Betting</button>
        <button id="close-bets" disabled>Close Betting</button>
        <button id="start-match" disabled>Start Match</button>
        <button id="end-match" disabled>End Match</button>
        <div id="resolve-bets"></div>
    </div>
    <div class="card">
<h2>Manage Betting Props</h2>

<!-- Admin props area: left = players/entity controls, right = add prop + current props -->
<div class="admin-section" style="display:flex; gap:20px; flex-wrap:wrap; align-items:flex-start;">

  <!-- Left column: player select + entity (player) management (JS will create entity controls if missing) -->
  <div style="min-width:260px; width:260px;">
    <label style="display:block; margin-bottom:6px;">Player:</label>
    <select id="prop-player" style="width:100%; padding:6px; margin-bottom:8px;"></select>

    <!-- NOTE: Do NOT remove this area ‚Äî renderEntityList() may create or update #entity-list -->
    <div id="players-list-wrapper" style="margin-top:8px;">
      <small style="opacity:0.8;">Players (use remove buttons):</small>
      <div id="entity-list" style="margin-top:8px;"></div>
    </div>
  </div>

  <!-- Right column: add prop & props list -->
  <div style="flex:1; min-width:300px;">
    <label style="display:block; margin-bottom:6px;">Add Prop</label>
    <input type="text" id="new-prop" placeholder="Enter prop name" style="padding:6px; width:60%;" />
    <input type="number" id="new-odds" placeholder="Odds (x)" min="1" style="padding:6px; width:30%; margin-left:6px;" />
    <button id="add-prop" type="button" style="display:block; margin-top:8px; padding:6px 8px;">Add Prop</button>

    <div style="margin-top:12px;">
      <h4 style="margin:6px 0;">Current Props</h4>
      <div id="props-list"></div>
    </div>
  </div>
</div>
</div>

<div class="admin-section">
  <h3>Current Players</h3>
  <div id="players-container" class="tag-list"></div>
</div>
    <div class="card">
  <h2>Admin Tests</h2>
  <button id="clear-votes">Clear Mvp Votes</button>
  <button id="normalize-roles" style="margin-left:10px;">Normalize Roles (set non-admins to false)</button>
  <button id="promote-me" style="margin-left:10px;">Make Me Admin (temp)</button>
  <button id="seed-config" style="margin-left:10px;">Seed Config Docs</button>
  <button id="reset-state" style="margin-left:10px;">Reset App State</button>
  <button id="debug-status" style="margin-left:10px;">Debug Status</button>
  <button id="set-match-num" style="margin-left:10px;">Set Match #‚Ä¶</button>
  <button id="season-reset" style="margin-left:10px; background:#4b0000; color:#fff;">‚ö†Ô∏è Full Season Reset</button>
    </div> 
</div>
</div>
</main>

<script>
// ------------------ STORAGE ------------------
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyAjq_4nylYza2VDiiT6KJq9VZ7auMe7gxo",
  authDomain: "kickcoins-v3.firebaseapp.com",
  projectId: "kickcoins-v3",
  storageBucket: "kickcoins-v3.appspot.com", // <-- FIXED
  messagingSenderId: "601991069210",
  appId: "1:601991069210:web:422a5389bcc9dd62845ba3",
  measurementId: "G-16L5MNM4E5"
};

// Initialize Firebase (exactly once)
firebase.initializeApp(firebaseConfig);
// Initialize services AFTER app init
const auth = firebase.auth();
const db   = firebase.firestore();
    // --- DIAG STEP 1A: check project details ---
setTimeout(()=>{
  const opts = firebase.app().options || {};
  alert(
    'Project: ' + (opts.projectId || '(none)') +
    '\nAuth domain: ' + (opts.authDomain || '(none)')
  );
}, 0);
    window.addEventListener('error', (e) => {
  alert('JS Error: ' + (e && e.message ? e.message : String(e)));
});
var users = {};

// === FIRESTORE ROSTERS ===
// Betting roster (was your old "players" doc)
let propEntities = [];
let propsTemplate = {};
let playersUnsub = null;
let propsUnsubs = {};

// MVP roster (separate doc so MVP voting list is independent)
let mvpEntities = [];
let mvpPlayersUnsub = null;
        function attachMvpPlayersListener() {
  if (mvpPlayersUnsub) { try { mvpPlayersUnsub(); } catch(_){} mvpPlayersUnsub = null; }

  // MVP roster lives at: /config/mvpPlayers { list: [...] }
  mvpPlayersUnsub = db.collection('config').doc('mvpPlayers').onSnapshot(
    (doc) => {
      const d = doc.data() || {};
      mvpEntities = Array.isArray(d.list) ? d.list : [];
      populateVoting(); // refresh MVP dropdowns
    },
    (err) => alert('MVP players listener error: ' + (err && err.message ? err.message : err))
  );
}
function attachPlayersListener() {
  if (playersUnsub) { playersUnsub(); playersUnsub = null; }

  playersUnsub = db.collection('config').doc('players').onSnapshot(
    (doc) => {
      const d = doc.data() || {};
      const newList = Array.isArray(d.list) ? d.list : [];

      // detach listeners for players that were removed
      Object.keys(propsUnsubs).forEach(p => {
        if (!newList.includes(p)) {
          try { propsUnsubs[p] && propsUnsubs[p](); } catch(_) {}
          delete propsUnsubs[p];
          delete propsTemplate[p];
        }
      });

      // attach listeners for any new players
      newList.forEach(p => { if (!propsUnsubs[p]) attachPropsListener(p); });

      propEntities = newList;

      // refresh UIs
      populatePlayers();   // betting dropdown
      populateVoting();    // MVP dropdowns
      populatePropAdmin(); // admin UI
    },
    (err) => alert('Players listener error: ' + (err && err.message ? err.message : err))
  );
}

function attachPropsListener(player) {
  if (propsUnsubs[player]) { try { propsUnsubs[player](); } catch(_) {} propsUnsubs[player] = null; }

  const ref = db.collection('config')
                .doc('propsTemplate')
                .collection('byPlayer')
                .doc(player);

  propsUnsubs[player] = ref.onSnapshot(
    (doc) => {
      const d = doc.data() || {};
      propsTemplate[player] = Array.isArray(d.items) ? d.items : [];

      // refresh if this player is currently in view
      if (document.getElementById('player-select')?.value === player) {
        populateProps();
      }
      if (document.getElementById('prop-player')?.value === player) {
        renderPropsList();
      }
    },
    (err) => alert('Props listener error (' + player + '): ' + (err && err.message ? err.message : err))
  );
}
let currentMatch = 0; // ‚úÖ keep a local var; Firestore listener keeps it in sync
let adminBetsUnsub = null; // live listener for unresolved bets (Firestore)
// === MVP (Firestore-driven) ===
let myVoteUnsub = null;
function detachMyVote() {
  if (myVoteUnsub) {
    myVoteUnsub();
    myVoteUnsub = null;
  }
}
let currentUser=null;
// === Firestore-backed "me" cache (single source of truth for balances/admin) ===
let __me = { coins: 0, availableCoins: 0, roles: { admin: false }, username: "" };
let __meUnsub = null;

function isSignedIn(){ return !!auth.currentUser; }
function isAdmin(){
  const a = __me && __me.roles ? __me.roles.admin : false;
  // tolerate boolean true, string "true", or number 1
  return a === true || a === 'true' || a === 1;
}
let myBetsUnsub = null; // live listener for "My Bets" (Firestore)

// ------------------ LOGIN ------------------
// ------------------ FIREBASE LOGIN / CREATE / LOGOUT ------------------
function renderBalanceFromFS(){
  const el = document.getElementById('balance-display');
  if (!el) return;
  el.textContent = `Total: ${__me.coins} üí∞ | Available: ${__me.availableCoins} üí∏`;
}
// Toggle login vs app UI
function showLogin(show=true){
    document.getElementById('login-card').style.display = show ? 'block' : 'none';
    document.getElementById('app').style.display = !show ? 'block' : 'none';
    document.getElementById('logout-btn').style.display = !show ? 'inline' : 'none';
}

// Helper: convert username to fake email
function usernameToEmail(username){
    return username + "@kickcoins.com";
}

// LOGIN
document.getElementById('login-btn').addEventListener('click', async ()=>{
    const username = document.getElementById('login-username').value.trim();
    const pass = document.getElementById('login-password').value;
    if(!username || !pass){ alert("Enter username and password."); return; }
    try {
        const email = usernameToEmail(username);
        await auth.signInWithEmailAndPassword(email, pass);
        currentUser = username;
        if(!users[username]){
            users[username] = { password:pass, totalCoins:100, availableCoins:0, votesThisMatch:{}, bets:[], mvpPoints:0, history:[], voted:false };
            localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
        }
        showLogin(false);
        updateUI(); populateVoting(); populatePlayers(); updateLeaderboards(); populatePropAdmin();
        alert("Logged in!");
    } catch(err){ alert("Login failed: " + err.message); }
});

// CREATE
// CREATE (allows create even if local user exists)
document.getElementById('create-btn').addEventListener('click', async ()=>{
  const username = document.getElementById('login-username').value.trim();
  const pass = document.getElementById('login-password').value;
  if(!username || !pass){ alert("Enter username and password."); return; }

  const email = usernameToEmail(username);

  try {
    // Try to create in Firebase Auth
    const cred = await auth.createUserWithEmailAndPassword(email, pass);
    await cred.user.updateProfile({ displayName: username });

    // Ensure local mirror exists (keeps rest of UI happy for now)
    if(!users[username]){
      users[username] = { password:pass, totalCoins:100, availableCoins:0, votesThisMatch:{}, bets:[], mvpPoints:0, history:[], voted:false };
      localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
    }

    currentUser = username;
    showLogin(false);
    updateUI(); populateVoting(); populatePlayers(); updateLeaderboards(); populatePropAdmin();
    alert("Account created & logged in!");
  } catch(err){
    if (err && err.code === 'auth/email-already-in-use') {
      // If account exists in Firebase, just sign in instead
      try {
        await auth.signInWithEmailAndPassword(email, pass);
        currentUser = username;
        if(!users[username]){
          users[username] = { password:pass, totalCoins:100, availableCoins:0, votesThisMatch:{}, bets:[], mvpPoints:0, history:[], voted:false };
          localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
        }
        showLogin(false);
        updateUI(); populateVoting(); populatePlayers(); updateLeaderboards(); populatePropAdmin();
        alert("Logged in!");
      } catch(signInErr){
        alert("Signup/Login failed: " + signInErr.message);
      }
    } else {
      alert("Signup failed: " + err.message);
    }
  }
});

// LOGOUT
document.getElementById('logout-btn').addEventListener('click', async ()=>{
  try {
    await auth.signOut();
  } catch (err) {
    alert("Logout failed: " + (err?.message || err));
    } finally {
    currentUser = null;
    showLogin(true);

    // Detach ALL listeners so anon user doesn‚Äôt trip "permission denied"
    try { if (myBetsUnsub)       { myBetsUnsub();       myBetsUnsub = null; } } catch(_){}
    try { if (myVoteUnsub)       { myVoteUnsub();       myVoteUnsub = null; } } catch(_){}
    try { if (adminBetsUnsub)    { adminBetsUnsub();    adminBetsUnsub = null; } } catch(_){}
    try { if (playersUnsub)      { playersUnsub();      playersUnsub = null; } } catch(_){}
    try { if (mvpPlayersUnsub)   { mvpPlayersUnsub();   mvpPlayersUnsub = null; } } catch(_){}
    try {
      Object.keys(propsUnsubs || {}).forEach(k=>{
        try { propsUnsubs[k] && propsUnsubs[k](); } catch(_){}
        delete propsUnsubs[k];
      });
    } catch(_) {}
    }
});
 // React to Firebase login state changes (SAFE VERSION)
auth.onAuthStateChanged(async (user) => {
  // Clean up previous listener
  if (__meUnsub) { try { __meUnsub(); } catch(_){} __meUnsub = null; }

  if (!user) {
    currentUser = null;
    __me = { coins: 0, availableCoins: 0, roles: { admin:false }, username: "" };
    showLogin(true);
    updateUI();
    refreshAdminButtons(); // ‚Üê add this
    return;
  }

  // derive username from profile or email
  const username = (user.displayName && user.displayName.trim())
    ? user.displayName.trim()
    : (user.email ? user.email.split("@")[0] : "user");
  currentUser = username;

  // ensure user doc exists
  const userRef = db.collection('users').doc(user.uid);
  let snap = await userRef.get();
  if (!snap.exists) {
    await userRef.set({
      email: user.email || null,
      username,
      coins: 100,
      availableCoins: 0,
      roles: { admin: false },
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
    snap = await userRef.get();
  }

  // live listener to my balances + roles
  __meUnsub = userRef.onSnapshot((doc) => {
    const d = doc.exists ? (doc.data() || {}) : {};
    __me = {
      coins: typeof d.coins === 'number' ? d.coins : 100,
      availableCoins: typeof d.availableCoins === 'number' ? d.availableCoins : 0,
      roles: d.roles || { admin: false },
      username: d.username || username
    };
    updateUI();           // header + admin tab vis
    renderBalanceFromFS(); // betting tab header
    refreshAdminButtons(); // ‚Üê add this
  });

  // proceed
 showLogin(false);
populateVoting();
populatePlayers();
updateLeaderboards();
populatePropAdmin();
attachPlayersListener();     // betting roster
attachMvpPlayersListener();  // MVP roster (new)
});
// ---------- FIRESTORE APP STATE ----------
const stateRef = db.collection('app').doc('state');

// Ensure the state doc exists once (safe to call always)
async function ensureState() {
  const snap = await stateRef.get();
  if (!snap.exists) {
    await stateRef.set({ bettingOpen: false, matchActive: false, currentMatch: 0 });
  }
}
ensureState();
// Ensure the config docs exist so listeners have something to read
async function ensureConfigDocs() {
  const cfg = db.collection('config');

  const playersDoc = await cfg.doc('players').get();
  if (!playersDoc.exists) {
    await cfg.doc('players').set({ list: [] }); // betting roster
  }

  const mvpPlayersDoc = await cfg.doc('mvpPlayers').get();
  if (!mvpPlayersDoc.exists) {
    await cfg.doc('mvpPlayers').set({ list: [] }); // MVP roster (separate)
  }

  const propsRoot = await cfg.doc('propsTemplate').get();
  if (!propsRoot.exists) {
    await cfg.doc('propsTemplate').set({}); // container for byPlayer
  }
}
ensureConfigDocs();

// Real-time listener to reflect buttons & keep local mirror in sync
// Real-time listener to reflect buttons, state mirror, live bets, and status bar
// === STATUS BAR RENDERER ===
// Optional: flip this to false if you don't want alert() popups on state changes.
const ENABLE_STATUS_ALERTS = false;

function renderStatusBar(st){
  const bar = document.getElementById('status-bar');
  if (!bar) return;

  // Clear previous classes
  bar.className = '';

  // Decide message + style
  const lines = [];
  // show current match number when available
  if (typeof st.currentMatch === 'number' && st.currentMatch > 0) {
    lines.push(`Match #${st.currentMatch}`);
  }

  if (st.bettingOpen) {
    lines.push('üü¢ Betting is LIVE ‚Äî don‚Äôt forget to place your bets!');
    bar.classList.add('open', 'pulse');
  } else {
    lines.push('‚ö™ Betting is closed ‚Äî check your results!');
    bar.classList.add('closed');
  }

  if (st.matchActive) {
    lines.push('üü¢ Match STARTED ‚Äî MVP voting is OPEN!');
    // keep pulse if either is live; already added when bettingOpen; add if only matchActive is live
    if (!bar.classList.contains('pulse')) bar.classList.add('pulse');
    bar.classList.add('started');
  } else {
    lines.push('‚ö™ Match not active');
    bar.classList.add('ended'); // gives a subtle different tone when not active
  }

  bar.textContent = lines.join(' ‚Ä¢ ');
  bar.style.display = 'block';
}

function maybeAnnounceStateChange(prev, st){
  if (!ENABLE_STATUS_ALERTS) return;
  // Use simple alerts for big state flips
  if (prev && prev.bettingOpen === false && st.bettingOpen === true) {
    alert('Betting is now LIVE ‚Äî 10 coins have been granted to all players.');
  }
  if (prev && prev.bettingOpen === true && st.bettingOpen === false) {
    alert('Betting is now CLOSED ‚Äî unused available coins were cleared.');
  }
  if (prev && prev.matchActive === false && st.matchActive === true) {
    alert('The match has STARTED ‚Äî MVP voting is now OPEN.');
  }
  if (prev && prev.matchActive === true && st.matchActive === false) {
    alert('The match has ENDED ‚Äî MVP votes will be tallied.');
  }
}
stateRef.onSnapshot((snap) => {
  if (!snap.exists) return;
  const st = snap.data();
  const prev = window.__appState || null;
  window.__appState = st;

  // keep your local currentMatch in sync
  if (typeof currentMatch !== 'undefined') currentMatch = Number(st.currentMatch || 0);

  // Admin button enable/disable (same logic, centralized)
  refreshAdminButtons && refreshAdminButtons();

  // Attach live "My Bets" listener for this match
  maybeAttachMyBetsListener(Number(st.currentMatch || 0));

  // NEW: render status bar for everyone
  renderStatusBar(st);

  // OPTIONAL: simple alert()s if you enable them
  maybeAnnounceStateChange(prev, st);
});
function maybeAttachMyBetsListener(matchNum){
  // Only if signed in and match number looks valid
  const u = auth.currentUser;
  if (!u || !Number.isFinite(matchNum) || matchNum <= 0) {
    if (myBetsUnsub) { myBetsUnsub(); myBetsUnsub = null; }
    renderMyBets([]); // clear the section
    return;
  }

  // Re-subscribe if match changed
  if (myBetsUnsub) { myBetsUnsub(); myBetsUnsub = null; }

  const q = db.collection('matches')
              .doc(String(matchNum))
              .collection('bets')
              .where('uid','==', u.uid);

  myBetsUnsub = q.onSnapshot((qsnap)=>{
    const bets = [];
    qsnap.forEach(doc => bets.push({ id: doc.id, ...doc.data() }));
    renderMyBets(bets);
  }, (err)=>{
    alert('Live bets listener error: ' + (err && err.message ? err.message : String(err)));
  });
}

function renderMyBets(bets){
  const container = document.getElementById('history-container');
  if (!container) return;

  // Remove existing FS section if present (so we can re-render)
  const old = document.getElementById('fs-my-bets');
  if (old) old.remove();

  const wrap = document.createElement('div');
  wrap.id = 'fs-my-bets';
  wrap.className = 'match-card';

  const title = document.createElement('strong');
  title.textContent = 'My Live Bets (Firestore)';
  wrap.appendChild(title);

  if (!bets.length) {
    const p = document.createElement('div');
    p.textContent = 'No bets yet for this match.';
    wrap.appendChild(p);
  } else {
    const ul = document.createElement('ul');
    let totalStake = 0, totalWon = 0;

    bets.forEach(b => {
      const li = document.createElement('li');
      li.textContent = `${b.player} - ${b.prop} (${b.odds}x) | Amount: ${b.amount} | ${b.resolved ? (b.won ? 'Won' : 'Lost') : 'Pending'}`;
      if (!b.resolved) li.style.color = 'yellow';
      else li.style.color = b.won ? 'green' : 'red';
      ul.appendChild(li);

      totalStake += Number(b.amount || 0);
      if (b.resolved && b.won) {
        totalWon += (Number(b.amount||0) * Number(b.odds||0)) + Number(b.amount||0);
      }
    });

    wrap.appendChild(ul);

    const totals = document.createElement('div');
    totals.className = 'total total-coins';
    totals.textContent = `Total Coins Bet: ${totalStake} | Total Coins Won: ${totalWon}`;
    if (totalWon < 10) totals.style.color = 'red';
    else if (totalWon === 10) totals.style.color = 'yellow';
    else totals.style.color = 'green';

    wrap.appendChild(totals);
  }

  // Prepend so it appears above your old local history (which we‚Äôll retire later)
  container.prepend(wrap);
}
// ========== FULL BET HISTORY (FIRESTORE) ‚Äì RENDERER ==========
function renderFullHistoryFS(bets) {
  const container = document.getElementById('history-container');
  if (!container) return;

  // Remove old FS section if present
  const old = document.getElementById('fs-full-history');
  if (old) old.remove();

  const wrap = document.createElement('div');
  wrap.id = 'fs-full-history';
  wrap.className = 'match-card';

  const title = document.createElement('strong');
  title.textContent = 'Full Bet History (Firestore)';
  wrap.appendChild(title);

  // Error state shortcut
  if (bets && bets.__error) {
    const p = document.createElement('div');
    p.style.color = 'red';
    p.textContent = 'Error: ' + bets.__error;
    wrap.appendChild(p);
    container.appendChild(wrap);
    return;
  }

  if (!bets || bets.length === 0) {
    const p = document.createElement('div');
    p.textContent = 'No bets yet.';
    wrap.appendChild(p);
    container.appendChild(wrap);
    return;
  }

  // Group by match number
  const byMatch = {};
  bets.forEach(b => {
    const m = Number(b.match || 0) || 0;
    if (!byMatch[m]) byMatch[m] = [];
    byMatch[m].push(b);
  });

  // Sort matches newest->oldest
  const matchNums = Object.keys(byMatch).map(n => Number(n)).sort((a,b)=>b-a);

  matchNums.forEach(matchNum => {
    const section = document.createElement('div');
    section.className = 'match-card';
    const header = document.createElement('strong');
    header.textContent = `Match ${matchNum}`;
    section.appendChild(header);

    const ul = document.createElement('ul');
    let totalStake = 0, totalWon = 0;

    // Sort each match‚Äôs bets newest->oldest
    const rows = byMatch[matchNum].slice().sort((a,b)=>{
      const ta = a.createdAt && a.createdAt.toMillis ? a.createdAt.toMillis() : 0;
      const tb = b.createdAt && b.createdAt.toMillis ? b.createdAt.toMillis() : 0;
      return tb - ta;
    });

    rows.forEach(b => {
      const li = document.createElement('li');
      li.textContent = `${b.player} - ${b.prop} (${b.odds}x) | Amount: ${b.amount} | ${b.resolved ? (b.won ? 'Won' : 'Lost') : 'Pending'}`;
      if (!b.resolved) li.style.color = 'yellow';
      else li.style.color = b.won ? 'green' : 'red';
      ul.appendChild(li);

      totalStake += Number(b.amount || 0);
      if (b.resolved && b.won) {
        totalWon += (Number(b.amount||0) * Number(b.odds||0)) + Number(b.amount||0);
      }
    });

    section.appendChild(ul);

    const totals = document.createElement('div');
    totals.className = 'total total-coins';
    totals.textContent = `Total Coins Bet: ${totalStake} | Total Coins Won: ${totalWon}`;
    if (totalWon < 10) totals.style.color = 'red';
    else if (totalWon === 10) totals.style.color = 'yellow';
    else totals.style.color = 'green';
    section.appendChild(totals);

    wrap.appendChild(section);
  });

  // Put full history BELOW the live ‚ÄúMy Bets‚Äù box
  container.appendChild(wrap);
}

// ========== FULL BET HISTORY (FIRESTORE) ‚Äì LOADER ==========
async function loadFullBetHistoryFS() {
  try {
    const u = auth.currentUser;
    if (!u) {
      renderFullHistoryFS([]); // signed-out -> empty
      return;
    }

    // Query all "bets" subcollections, only my uid; sort on client
    const q = db.collectionGroup('bets').where('uid','==', u.uid);
    const qsnap = await q.get();

    const rows = [];
    qsnap.forEach(doc => rows.push({ id: doc.id, ...doc.data() }));

    // Sort: newest match first, then newest createdAt first
    rows.sort((a,b) => {
      const ma = Number(a.match || 0), mb = Number(b.match || 0);
      if (mb !== ma) return mb - ma;
      const ta = a.createdAt && a.createdAt.toMillis ? a.createdAt.toMillis() : 0;
      const tb = b.createdAt && b.createdAt.toMillis ? b.createdAt.toMillis() : 0;
      return tb - ta;
    });

    renderFullHistoryFS(rows);
  } catch (err) {
    renderFullHistoryFS({ __error: (err && err.message ? err.message : String(err)) });
  }
}
async function renderCoinLeaderboardFS(){
  const tbody = document.querySelector('#coin-leaderboard tbody');
  if (!tbody) return;
  tbody.innerHTML = '';

  try {
    const snap = await db.collection('users')
      .where('roles.admin', '==', false)
      .orderBy('coins', 'desc')
      .get();

    let rank = 1;
    snap.forEach(doc => {
      const d = doc.data() || {};
      // Skip archived users (active:false). Treat missing as active.
      if (d.active === false) return;

      const name = d.username || '(user)';
      const coins = typeof d.coins === 'number' ? d.coins : 0;

      const icon = rank===1?'ü•á':rank===2?'ü•à':rank===3?'ü•â':rank<7?'ü™®':'üçÜ';
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${rank} ${icon}</td><td>${name}</td><td>${coins}</td><td></td>`;
      tbody.appendChild(tr);
      rank++;
    });

    if (rank === 1) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td colspan="4" style="opacity:.8;">No active players yet.</td>`;
      tbody.appendChild(tr);
    }
  } catch (e) {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td colspan="4" style="color:red;">Leaderboard load failed: ${e && e.message ? e.message : e}</td>`;
    tbody.appendChild(tr);
  }
}
// ------------------ TAB NAV ------------------
document.querySelectorAll('.tab').forEach(tab=>{
  tab.addEventListener('click',()=>{
    // switch active tab
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    tab.classList.add('active');
    // switch visible content
    document.querySelectorAll('.tab-content').forEach(tc=>tc.style.display='none');
    document.getElementById(tab.dataset.tab+'-tab').style.display='block';

    updateUI();

    if (tab.dataset.tab === "history") {
      // keep your old local history for now (we‚Äôll remove later)
      // üî¥ NEW: Firestore leaderboard + full history
      renderCoinLeaderboardFS(); 
      loadFullBetHistoryFS();     // <<-- this replaces your old renderFullHistoryFS()
    }

    if (tab.dataset.tab === "admin" && currentUser && isAdmin()) {
      renderPropsList();
      reviewBetsForAdminFS();
      refreshAdminButtons(); // ‚Üê add this
    }
    // inside tab click handler:
if (tab.dataset.tab === "vote") {
  populateVoting(); // ensures listener attaches / UI fills
}
  });
});

// ------------------ ACCOUNT DISPLAY ------------------
function updateUI(){
  // account header
  const accEl = document.getElementById('account-info');
  if (accEl) {
    const name = currentUser || '(signed out)';
    accEl.innerHTML = `${name} | Total: ${__me.coins} üí∞ | Available: ${__me.availableCoins} üí∏`;
  }
  // Admin tab visibility based on Firestore role (not local mirror)
  const adminTab = document.querySelector('.tab[data-tab="admin"]');
  const adminContent = document.getElementById('admin-tab');
  if (adminTab && adminContent) {
    if (isAdmin()) {
      adminTab.style.display = "block";
    } else {
      adminTab.style.display = "none";
      adminContent.style.display = "none";
      const active = document.querySelector(".tab.active");
      if (active && active.dataset.tab === "admin") {
        document.querySelector('.tab[data-tab="vote"]').click();
      }
    }
  }
}
function refreshAdminButtons(){
  const st = window.__appState || {};
  const userIsAdmin = isAdmin();

  const ob = document.getElementById('open-bets');
  const cb = document.getElementById('close-bets');
  const sm = document.getElementById('start-match');
  const em = document.getElementById('end-match');

  if (ob) ob.disabled = !userIsAdmin || !!st.bettingOpen;
  if (cb) cb.disabled = !userIsAdmin || !st.bettingOpen;
  if (sm) sm.disabled = !userIsAdmin || !!st.matchActive || !!st.bettingOpen;
  if (em) em.disabled = !userIsAdmin || !st.matchActive;
}
// ------------------ MVP VOTING (Firestore) ------------------
function populateVoting(){
  // Use the MVP roster only
  ["vote1","vote2","vote3"].forEach(id=>{
    const sel = document.getElementById(id);
    sel.innerHTML = "";
    (mvpEntities || []).forEach(p=>{
      const opt = document.createElement("option");
      opt.value = p;
      opt.text = p;
      sel.appendChild(opt);
    });
  });

  // Attach / reattach the listener that will also prefill votes if they exist
  attachMyVoteListener();
}
function attachMyVoteListener(){
  detachMyVote();
  const st = window.__appState || {};
  const matchNum = Number(st.currentMatch || 0);
  const u = auth.currentUser;
  if (!u || !matchNum) return;

  const voteRef = db.collection('matches').doc(String(matchNum)).collection('votes').doc(u.uid);
  myVoteUnsub = voteRef.onSnapshot((doc)=>{
    const btnEl = document.getElementById('submit-votes');
    if (!btnEl) return;

    if (!doc.exists) {
      // no vote yet
      btnEl.disabled = false;
      btnEl.textContent = 'Submit Votes';
      return;
    }

    // pre-fill UI
    const v = doc.data() || {};
    if (v.first  && mvpEntities.includes(v.first))  document.getElementById('vote1').value = v.first;
    if (v.second && mvpEntities.includes(v.second)) document.getElementById('vote2').value = v.second;
    if (v.third  && mvpEntities.includes(v.third))  document.getElementById('vote3').value = v.third;

    // üîí Respect lock
    const locked = !!v.locked;
    ['vote1','vote2','vote3'].forEach(id=>{
      const el = document.getElementById(id);
      if (el) el.disabled = locked;
    });

    if (locked) {
      btnEl.disabled = true;
      btnEl.textContent = 'Vote Locked';
    } else {
      btnEl.disabled = false;
      btnEl.textContent = 'Submit Votes';
    }
  }, (err)=>{
    alert('Vote listener error: ' + (err && err.message ? err.message : err));
  });
}

document.getElementById('submit-votes').addEventListener('click', async ()=>{
  try {
    const st = window.__appState || {};
    if (!st.matchActive) { alert("Match not started yet."); return; }

    const u = auth.currentUser;
    if (!u) { alert("Not signed in."); return; }

    const first  = document.getElementById('vote1').value;
    const second = document.getElementById('vote2').value;
    const third  = document.getElementById('vote3').value;

    if (new Set([first,second,third]).size < 3) {
      alert("Cannot vote the same player multiple times.");
      return;
    }

    const matchNum = Number(st.currentMatch || 0);
    if (!matchNum) { alert('No active match id.'); return; }

    // üî¥ Confirm before finalizing
    const confirmMsg = `Are you sure you want to cast your votes?\n\n1st: ${first}\n2nd: ${second}\n3rd: ${third}\n\nThis cannot be undone.`;
    if (!confirm(confirmMsg)) return;

    // üîí Save once with locked=true
    await db.collection('matches').doc(String(matchNum)).collection('votes').doc(u.uid).set({
      uid: u.uid,
      username: currentUser || '',
      first, second, third,
      locked: true,
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge: true });

    alert('Your vote has been locked for this match!');
  } catch (e) {
    alert('Submit votes failed: ' + (e && e.message ? e.message : e));
  }
});

// ------------------ BETTING ------------------
function populatePlayers(){
    let sel=document.getElementById('player-select'); sel.innerHTML="";
    propEntities.forEach(p=>{
        let opt=document.createElement("option"); opt.value=p; opt.text=p; sel.appendChild(opt);
    });
    sel.addEventListener('change', populateProps);
}
function populateProps(){
  const container = document.getElementById('props-container');
  container.innerHTML = "";
  const player = document.getElementById('player-select').value;
  const avail = Number(__me.availableCoins || 0);

  (propsTemplate[player] || []).forEach(prop=>{
    const card = document.createElement("div");
    card.className = "prop";

    const label = document.createElement("span");
    label.textContent = `${prop.name} (${prop.odds}x)`;
    label.className = "green";

    const input = document.createElement("input");
    input.type = "number";
    input.min = 0;
    input.max = avail;                      // üî¥ from Firestore now
    input.dataset.odds = prop.odds;
    input.oninput = updatePotentialPayout;

    card.appendChild(label);
    card.appendChild(input);
    container.appendChild(card);
  });

  updatePotentialPayout();
}
function updatePotentialPayout(){
    const container=document.getElementById('props-container');
    let total=0;
    for(let p of container.children){
        let input=p.querySelector('input'); let amt=Number(input.value); let odds=Number(input.dataset.odds);
        if(amt>0){ total += amt*odds + amt; }
    }
    const payoutDisplay=document.getElementById('total-payout');
    payoutDisplay.textContent=total; payoutDisplay.style.color=total>50?'green':'yellow';
}
document.getElementById('submit-bets').addEventListener('click', async ()=>{
  try {
    const st = window.__appState || {};
    if (!st.bettingOpen) { alert('Betting not open.'); return; }

    const u = auth.currentUser;
    if (!u) { alert('Not signed in.'); return; }

    const username = currentUser;
    const userDocRef = db.collection('users').doc(u.uid);

    // Collect bet inputs from the UI
    const container = document.getElementById('props-container');
    const player = document.getElementById('player-select').value;

    // Build an array of {propName, odds, amount} from the inputs
    const entries = [];
    for (let node of container.children) {
      const label = node.querySelector('span')?.textContent || '';
      const input = node.querySelector('input');
      if (!input) continue;
      const amt = Number(input.value || 0);
      const odds = Number(input.dataset.odds || 0);
      if (amt > 0 && odds > 0) {
        entries.push({
          propName: label.split(' (')[0], // "Score (4x)" -> "Score"
          odds,
          amount: amt
        });
      }
    }

    if (entries.length === 0) {
      alert('Enter at least one bet amount.');
      return;
    }

    // Sum up total to deduct
    const totalStake = entries.reduce((s, e) => s + e.amount, 0);

    // Do everything atomically
    await db.runTransaction(async (tx) => {
      // 1) Check app state
      const stateSnap = await tx.get(stateRef);
      if (!stateSnap.exists) throw new Error('App state missing.');
      const state = stateSnap.data() || {};
      const currentMatch = Number(state.currentMatch || 0);
      if (!state.bettingOpen) throw new Error('Betting is not open.');

      // 2) Check user funds
      const userSnap = await tx.get(userDocRef);
      if (!userSnap.exists) throw new Error('User profile missing.');
      const d = userSnap.data() || {};
      const avail = Number(d.availableCoins || 0);
      if (totalStake > avail) throw new Error('Insufficient available coins.');

      // 3) Create bet docs under the current match
      const betsCol = db.collection('matches').doc(String(currentMatch)).collection('bets');
      const now = firebase.firestore.FieldValue.serverTimestamp();

      entries.forEach((e) => {
        const betRef = betsCol.doc(); // auto id
        tx.set(betRef, {
          uid: u.uid,
          username: username,
          match: currentMatch,
          player: player,
          prop: e.propName,
          odds: e.odds,
          amount: e.amount,
          resolved: false,
          won: false,
          createdAt: now
        });
      });

      // 4) Deduct availableCoins
      tx.update(userDocRef, {
        availableCoins: avail - totalStake
      });
    });

    // Clear inputs + refresh UI
    for (let node of document.getElementById('props-container').children) {
      const input = node.querySelector('input');
      if (input) input.value = '';
    }
    updatePotentialPayout();
    alert('Bets placed!');

  } catch (err) {
    alert('Place bets failed: ' + (err && err.message ? err.message : String(err)));
  }
});
// ------------------ ADMIN BET CONTROL ------------------
document.getElementById('open-bets').addEventListener('click', async ()=>{
  if (!currentUser || !isAdmin()) return;

  try {
    // 1) Flip app state (increment match, open betting, ensure match not active)
    await stateRef.set({
      bettingOpen: true,
      matchActive: false,
      currentMatch: firebase.firestore.FieldValue.increment(1)
    }, { merge: true });

    // 2) Give coins to all non-admin users (batch for speed)
    const usersSnap = await db.collection('users').get();
    const batch = db.batch();
    usersSnap.forEach(doc => {
      const d = doc.data() || {};
      const isAdmin = d.roles && d.roles.admin === true;
      if (isAdmin) return;

      const total = typeof d.coins === 'number' ? d.coins : 100;
      const avail = typeof d.availableCoins === 'number' ? d.availableCoins : 0;

      // same logic you had locally:
      const grant = Math.min(10, total);       // cannot grant more than they have
      const newTotal = total - grant;
      const newAvail = avail + grant;

      batch.set(doc.ref, {
        coins: newTotal,
        availableCoins: newAvail,
        voted: false // optional: clears voted for new match, like before
      }, { merge: true });
    });
    await batch.commit();

    alert('Betting opened and balances granted.');
  } catch (e) {
    alert('Open betting failed: ' + (e && e.code ? e.code + ' - ' : '') + (e && e.message ? e.message : e));
  }
});
  // We will handle coins later when we move coins to Firestore.
document.getElementById('close-bets').addEventListener('click', async ()=>{
  if (!currentUser || !isAdmin()) return;

  try {
    // 1) Flip app state
    await stateRef.set({ bettingOpen: false }, { merge: true });

    // 2) Zero availableCoins for all non-admins (only if needed) and count how many were changed
    const usersSnap = await db.collection('users').get();
    const batch = db.batch();
    let touched = 0;

    usersSnap.forEach(doc => {
  const d = doc.data() || {};
  const isA = d.roles && d.roles.admin === true; // skip admins
  if (isA) return;

  const currentAvail = Number(d.availableCoins || 0);
  if (currentAvail !== 0) {
    batch.set(doc.ref, { availableCoins: 0 }, { merge: true });
    touched++;
  }
});

    if (touched > 0) {
      await batch.commit();
    }

    alert('Betting closed. Zeroed availableCoins for ' + touched + ' user(s).');
  } catch (e) {
    alert('Close betting failed: ' + (e && e.code ? e.code + ' - ' : '') + (e && e.message ? e.message : e));
  }
});
document.getElementById('start-match').addEventListener('click', async ()=>{
  if (!currentUser || !isAdmin()) return;
  try {
    await stateRef.update({ matchActive: true });
    reviewBetsForAdminFS(); // <-- Firestore version (REPLACED LINE)
    alert('Match started.');
  } catch (e) {
    alert('Start match failed: ' + (e && e.message ? e.message : e));
  }
});
document.getElementById('end-match').addEventListener('click', async ()=>{
  if (!currentUser || !isAdmin()) return;

  try {
    // 1) Mark match as inactive first
    await stateRef.update({ matchActive: false });

    // 2) Resolve Firestore listener for admin cards
    if (adminBetsUnsub) { adminBetsUnsub(); adminBetsUnsub = null; }

    // 3) Compute MVP from votes in this match + write results + update totals
    const st = window.__appState || {};
    const matchNum = Number(st.currentMatch || 0);
    if (!matchNum) throw new Error('No match number to close.');

    await computeMvpAndPersistFS(matchNum);

    alert('Match ended & MVP tallied.');
    updateLeaderboards(); // refresh MVP UI
  } catch (e) {
    alert('End match failed: ' + (e && e.message ? e.message : e));
  }
});

async function computeMvpAndPersistFS(matchNum){
  // read all votes for the match
  const votesSnap = await db.collection('matches').doc(String(matchNum)).collection('votes').get();

  // tally points
  const tally = {}; // player -> points
  const results = []; // for pretty match card history
  votesSnap.forEach(doc=>{
    const v = doc.data() || {};
    if (v.first)  tally[v.first]  = (tally[v.first]  || 0) + 5;
    if (v.second) tally[v.second] = (tally[v.second] || 0) + 3;
    if (v.third)  tally[v.third]  = (tally[v.third]  || 0) + 2;
  });

  // build per-player result array (sorted desc points)
  const rows = Object.keys(tally).map(player=>({ player, points: tally[player] }));
  rows.sort((a,b)=>b.points - a.points);

  // decorate with place medals for top 3 (optional / keeps your UI style)
  rows.forEach((r, i)=>{
    r.place = (i===0?'1st':i===1?'2nd':i===2?'3rd':''); // empty for >3, still shows points
  });

  // write match result doc
  await db.collection('matches').doc(String(matchNum)).collection('mvpResult').doc('summary').set({
    match: matchNum,
    results: rows,
    createdAt: firebase.firestore.FieldValue.serverTimestamp()
  }, { merge: true });

  // update global mvpScores (increment per player)
  const batch = db.batch();
  rows.forEach(r=>{
    const ref = db.collection('mvpScores').doc(r.player);
    batch.set(ref, { points: firebase.firestore.FieldValue.increment(r.points) }, { merge: true });
  });
  await batch.commit();
}

// ------------------ REVIEW & RESOLVE BETS ------------------
// ------------------ REVIEW & RESOLVE BETS ------------------
function reviewBetsForAdminFS(){
  const resolveDiv = document.getElementById('resolve-bets');
  if (!resolveDiv) return;

  resolveDiv.innerHTML = "<h3>Resolve Bets (Firestore)</h3>";

  // Only show for admins
  const userIsAdmin = isAdmin();
  if (!userIsAdmin) {
    const p = document.createElement('div');
    p.textContent = 'Admin only.';
    resolveDiv.appendChild(p);
    return;
  }

  // Need a current match number
  const st = window.__appState || {};
  const matchNum = Number(st.currentMatch || 0);
  if (!matchNum) {
    const p = document.createElement('div');
    p.textContent = 'No active match yet.';
    resolveDiv.appendChild(p);
    if (adminBetsUnsub) { adminBetsUnsub(); adminBetsUnsub = null; }
    return;
  }

  // Re-subscribe fresh each time
  if (adminBetsUnsub) { adminBetsUnsub(); adminBetsUnsub = null; }

  const q = db.collection('matches')
              .doc(String(matchNum))
              .collection('bets')
              .where('resolved', '==', false);

  adminBetsUnsub = q.onSnapshot((qsnap) => {
    resolveDiv.innerHTML = "<h3>Resolve Bets (Firestore)</h3>";

    // Group by (player, prop, odds)
    const groups = {};
    qsnap.forEach(doc => {
      const d = doc.data();
      const key = `${d.player}||${d.prop}||${d.odds}`;
      if (!groups[key]) groups[key] = [];
      groups[key].push({ id: doc.id, ...d });
    });

    const keys = Object.keys(groups);
    if (keys.length === 0) {
      const p = document.createElement('div');
      p.textContent = 'No unresolved bets.';
      resolveDiv.appendChild(p);
      return;
    }

    keys.forEach(key => {
      const betGroup = groups[key];
      const sample = betGroup[0];

      const div = document.createElement('div');
      div.className = 'admin-bet-card';

      const totalStake = betGroup.reduce((sum, b) => sum + Number(b.amount || 0), 0);
      div.innerHTML = `${sample.player} - ${sample.prop} | Odds: ${sample.odds}x | Bets: ${betGroup.length} | Total Staked: ${totalStake}`;

      const winBtn = document.createElement('button');
      winBtn.textContent = 'Win';
      winBtn.className = 'admin-win-btn';

      const loseBtn = document.createElement('button');
      loseBtn.textContent = 'Lose';
      loseBtn.className = 'admin-lose-btn';

      winBtn.onclick  = () => resolveBetGroupFS(matchNum, betGroup, true,  div);
      loseBtn.onclick = () => resolveBetGroupFS(matchNum, betGroup, false, div);

      div.appendChild(winBtn);
      div.appendChild(loseBtn);
      resolveDiv.appendChild(div);
    });

  }, (err) => {
    const p = document.createElement('div');
    p.style.color = 'red';
    p.textContent = 'Admin bets listener error: ' + (err && err.message ? err.message : String(err));
    resolveDiv.appendChild(p);
  });
}
async function resolveBetGroupFS(matchNum, betGroup, won, cardEl){
  // Extra guard‚Äîadmin only
  if (!isAdmin()) return;

  try {
    const batch = db.batch();

    betGroup.forEach(b => {
      const betRef = db.collection('matches')
                       .doc(String(matchNum))
                       .collection('bets')
                       .doc(b.id);

      // Mark resolved
      batch.update(betRef, { resolved: true, won: !!won });

      // If win, pay the user: payout = amt * odds + amt
      if (won) {
        const payout = (Number(b.amount || 0) * Number(b.odds || 0)) + Number(b.amount || 0);
        const userRef = db.collection('users').doc(b.uid);
        batch.update(userRef, { coins: firebase.firestore.FieldValue.increment(payout) });
      }
    });

    await batch.commit();

    if (cardEl) cardEl.remove();
    alert(`Marked ${betGroup.length} bet(s) as ${won ? 'WIN' : 'LOSE'}.`);
  } catch (e) {
    alert('Resolve failed: ' + (e && e.message ? e.message : e));
  }
}

// ------------------ LEADERBOARDS (MVP via Firestore) ------------------
async function updateLeaderboards(){
  // MVP leaderboard totals
  try {
    const tbody = document.getElementById('mvp-leaderboard').querySelector('tbody');
    tbody.innerHTML = '';
    const snap = await db.collection('mvpScores').orderBy('points','desc').get();
    let rank = 1;
    snap.forEach(doc=>{
      const d = doc.data() || {};
      const name = doc.id; // we use player name as doc id
      const pts  = typeof d.points === 'number' ? d.points : 0;
      const icon = rank===1?'ü•á':rank===2?'ü•à':rank===3?'ü•â':rank<7?'ü™®':'üçÜ';
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${rank} ${icon}</td><td>${name}</td><td>${pts}</td>`;
      tbody.appendChild(tr);
      rank++;
    });
  } catch (e) {
    const tbody = document.getElementById('mvp-leaderboard').querySelector('tbody');
    const tr = document.createElement('tr');
    tr.innerHTML = `<td colspan="3" style="color:red;">MVP leaderboard failed: ${e && e.message ? e.message : e}</td>`;
    tbody.appendChild(tr);
  }

  // MVP history per match
  try {
    const wrap = document.getElementById('mvp-history');
    wrap.innerHTML = '';

    // Grab latest ~20 match results (you can tweak)
    // We don‚Äôt have an index field besides matchId; we‚Äôll read a handful by id if needed.
    // Simpler: read all mvpResult docs (small scale).
    const qs = await db.collectionGroup('mvpResult').get();

    // Group by match, sort desc by numeric match
    const results = [];
    qs.forEach(doc=>{
      const path = doc.ref.parent.parent; // .../matches/{matchId}
      const matchNum = path ? Number(path.id) : 0;
      results.push({ match: matchNum, ...doc.data() });
    });
    results.sort((a,b)=>b.match - a.match);

    results.forEach(r=>{
      const div = document.createElement('div');
      div.className = 'mvp-card';
      div.innerHTML = `<strong>Match ${r.match}</strong>`;

      (r.results || []).forEach(item=>{
        // item: { player, points, place }
        const emoji = item.points===5?'ü•á':item.points===3?'ü•à':item.points===2?'ü•â':(item.points>=1 && item.points<=7?'ü™®':'üçÜ');
        const line = document.createElement('div');
        line.className = 'result';
        line.textContent = `${emoji} ${item.place}: ${item.player} (+${item.points})`;
        div.appendChild(line);
      });

      wrap.appendChild(div);
    });

  } catch (e) {
    const wrap = document.getElementById('mvp-history');
    const err = document.createElement('div');
    err.style.color = 'red';
    err.textContent = 'MVP history load failed: ' + (e && e.message ? e.message : e);
    wrap.appendChild(err);
  }

  // NOTE: coin leaderboard is handled elsewhere (renderCoinLeaderboardFS)
}

// ------------------ HISTORY ------------------

// ------------------ ADMIN PROP MANAGEMENT ------------------
function populatePropAdmin(){
  const sel = document.getElementById('prop-player');
  sel.innerHTML = "";

  (propEntities || []).forEach(p=>{
    const opt = document.createElement("option");
    opt.value = p;
    opt.text  = p;
    sel.appendChild(opt);
  });

  // Render lists
  renderPropsList();
  renderEntityList();

  // --- ADD ENTITY MANAGEMENT CONTROLS (Add Player) ---
  let entityContainer = document.getElementById('prop-entity-container');
  if (!entityContainer) {
    entityContainer = document.createElement('div');
    entityContainer.id = 'prop-entity-container';
    entityContainer.style.margin = "10px 0";

    const input = document.createElement('input');
    input.type = 'text';
    input.id = 'new-entity';
    input.placeholder = 'Enter new player';
    input.style.margin = "0 0 10px 0";
    input.style.padding = "6px";
    input.style.width = "100%";

    const addBtn = document.createElement('button');
    addBtn.textContent = 'Add Player';
    addBtn.style.marginTop = "6px";

    addBtn.onclick = async ()=>{
      if (!isAdmin()) return;
      const name = (document.getElementById('new-entity').value || '').trim();
      if (!name) { alert('Enter a player name'); return; }
      if ((propEntities || []).includes(name)) { alert('Player already exists'); return; }

      try {
        // 1) Add to players list
        await db.collection('config').doc('players').set({
          list: firebase.firestore.FieldValue.arrayUnion(name)
        }, { merge: true });

        // 2) Default props doc for the player
        await db.collection('config')
          .doc('propsTemplate')
          .collection('byPlayer')
          .doc(name)
          .set({
            items: [
              { name:'Score',    odds:4 },
              { name:'Assist',   odds:3 },
              { name:'Anything', odds:2 }
            ]
          }, { merge: true });

        document.getElementById('new-entity').value = '';
        alert('Player added.');
        // UI auto-refreshes via attachPlayersListener()
      } catch (e) {
        alert('Add player failed: ' + (e?.message || e));
      }
    };

    entityContainer.appendChild(input);
    entityContainer.appendChild(addBtn);
    sel.parentNode.insertBefore(entityContainer, sel.nextElementSibling);
  }
}
    function renderEntityList(){
  let container = document.getElementById('entity-list');
  if (!container) {
    container = document.createElement('div');
    container.id = 'entity-list';
    container.style.margin = "10px 0";
    document.getElementById('prop-player').parentNode.appendChild(container);
  }
  container.innerHTML = "";

  (propEntities || []).forEach((playerName)=>{
    const row = document.createElement('div');
    row.style.margin = "6px 0";
    row.textContent = playerName + " ";

    const btn = document.createElement('button');
    btn.textContent = "Remove";
    btn.style.marginLeft = "10px";
    btn.style.padding = "3px 8px";
    btn.style.backgroundColor = "#ff4d4d";
    btn.style.color = "#fff";
    btn.style.border = "none";
    btn.style.borderRadius = "4px";
    btn.style.cursor = "pointer";

    btn.onclick = async ()=>{
      if (!isAdmin()) return;
      if (!confirm(`Remove player "${playerName}" from betting? This also clears their props.`)) return;

      try {
        await db.collection('config').doc('players').set({
          list: firebase.firestore.FieldValue.arrayRemove(playerName)
        }, { merge: true });

        await db.collection('config')
          .doc('propsTemplate')
          .collection('byPlayer')
          .doc(playerName)
          .delete();

        alert('Player removed.');
        // UI auto-refreshes via listeners
      } catch (e) {
        alert('Remove player failed: ' + (e?.message || e));
      }
    };

    row.appendChild(btn);
    container.appendChild(row);
  });
}
function renderPropsList(){
  const container = document.getElementById('props-list');
  if (!container) return;
  container.innerHTML = "";

  const player = document.getElementById('prop-player').value;
  const items = (propsTemplate[player] || []);

  items.forEach((p)=>{
    const div = document.createElement('div');
    div.style.margin = "6px 0";
    div.textContent = `${p.name} (${p.odds}x) `;

    const btn = document.createElement('button');
    btn.textContent = "Remove";
    btn.style.marginLeft = "10px";
    btn.onclick = async ()=>{
      if (!isAdmin()) return;
      if (!confirm(`Remove prop "${p.name}" from ${player}?`)) return;

      try {
        await db.collection('config')
          .doc('propsTemplate')
          .collection('byPlayer')
          .doc(player)
          .set({
            items: firebase.firestore.FieldValue.arrayRemove({ name: p.name, odds: p.odds })
          }, { merge: true });
        // UI auto-updates via props listener
      } catch (e) {
        alert('Remove prop failed: ' + (e?.message || e));
      }
    };

    div.appendChild(btn);
    container.appendChild(div);
  });
}

// Add new prop
document.getElementById('add-prop').addEventListener('click', async ()=>{
  if (!currentUser || !isAdmin()) return;

  const player = document.getElementById('prop-player').value;
  const name = (document.getElementById('new-prop').value || '').trim();
  const odds = parseInt(document.getElementById('new-odds').value, 10);

  if (!player) { alert('Select a player'); return; }
  if (!name || !(odds > 0)) { alert('Enter valid prop name and odds'); return; }

  try {
    await db.collection('config')
      .doc('propsTemplate')
      .collection('byPlayer')
      .doc(player)
      .set({
        items: firebase.firestore.FieldValue.arrayUnion({ name, odds })
      }, { merge: true });

    document.getElementById('new-prop').value = '';
    document.getElementById('new-odds').value = '';
    alert('Prop added.');
    // UI auto-updates via listener
  } catch (e) {
    alert('Add prop failed: ' + (e?.message || e));
  }
});
// ------------------ DELETE USER ------------------
function deleteUser(username){
    if(!currentUser || !isAdmin()) return;
    if(confirm(`Admin, confirm delete ${username}?`)){ delete users[username]; updateLeaderboards(); updateUI(); alert(`${username} deleted`); }
}

// ------------------ CLEAR VOTES ------------------
document.getElementById('clear-votes').addEventListener('click',()=>{
    if(!currentUser || !isAdmin()) return;
    Object.keys(users).forEach(u=>users[u].votesThisMatch={});
    mvpScores={}; mvpHistory=[]; currentMatch=0;
    localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
    localStorage.removeItem('mvpScores'); localStorage.removeItem('mvpHistory'); localStorage.setItem('currentMatch', currentMatch);
    updateLeaderboards(); updateUI(); alert("Votes cleared.");
});
// TEMP ‚Äî one-time cleanup: set roles.admin=false for any non-admin missing it
document.getElementById('normalize-roles').addEventListener('click', async ()=>{
  // must be admin in your local model
  if (!currentUser || !isAdmin()) {
    alert('Admin only'); 
    return; 
  }

  try {
    const qs = await db.collection('users').get();
    const batch = db.batch();
    let touched = 0;

    qs.forEach(doc => {
      const d = doc.data() || {};
      const isAdmin = d.roles && d.roles.admin === true;

      // If NOT admin and (roles missing OR roles.admin not boolean), set false
      if (!isAdmin) {
        const hasRoles = !!d.roles;
        const hasBool = hasRoles && (typeof d.roles.admin === 'boolean');
        if (!hasBool) {
          batch.set(doc.ref, { roles: { admin: false } }, { merge: true });
          touched++;
        }
      }
    });

    if (touched > 0) {
      await batch.commit();
      alert('Roles normalized on ' + touched + ' user(s).');
    } else {
      alert('No changes needed ‚Äî everyone already has roles.admin.');
    }
  } catch (e) {
    alert('Normalize failed: ' + (e && e.message ? e.message : e));
  }
});
// TEMP: Promote the current user to admin. Remove after use.
document.getElementById('promote-me').addEventListener('click', async ()=>{
  const u = auth.currentUser;
  if(!u){ alert("Not signed in."); return; }

  // Safety: only allow if the username is exactly 'admin'
  const uname = (u.displayName && u.displayName.trim()) ? u.displayName.trim() : (u.email ? u.email.split("@")[0] : "");
  if (uname !== 'admin') {
    alert("For safety, only the 'admin' user can self-promote here.");
    return;
  }

  try {
    await db.collection('users').doc(u.uid).set({ roles: { admin: true } }, { merge: true });
    // Keep your local flag in sync so the Admin tab shows
    if (!users[uname]) users[uname] = {};
    users[uname].isAdmin = true;
    localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
    updateUI();

    alert("You're now an admin. (Remove this button after confirming.)");
  } catch (e) {
    alert("Failed to promote: " + e.message);
  }
});
// TEMP: Seed config docs with defaults (players, props, MVP players)
document.getElementById('seed-config').addEventListener('click', async ()=>{
  if (!isAdmin()) { alert("Admin only."); return; }

  try {
    const cfg = db.collection('config');

    // Betting roster
    await cfg.doc('players').set({
      list: ["Erick","Yansy","Bernie","Erubial","Samir","Angel","Abel","Alan","Ace"]
    }, { merge: true });

    // MVP roster
    await cfg.doc('mvpPlayers').set({
      list: ["Erick","Yansy","Bernie","Erubial","Samir","Angel","Abel","Alan","Ace"]
    }, { merge: true });

    // Default props
    const defaultProps = [
      { name:'Score', odds:4 },
      { name:'Assist', odds:3 },
      { name:'Anything', odds:2 }
    ];

    for (const p of ["Erick","Yansy","Bernie","Erubial","Samir","Angel","Abel","Alan","Ace"]) {
      await cfg.doc('propsTemplate')
        .collection('byPlayer')
        .doc(p)
        .set({ items: defaultProps }, { merge: true });
    }

    alert("Config seeded with players, MVP list, and default props.");
  } catch (e) {
    alert("Seed config failed: " + (e && e.message ? e.message : e));
  }
});
// TEMP: Reset app state so admin buttons unlock easily
document.getElementById('reset-state').addEventListener('click', async ()=>{
  if (!isAdmin()) { alert("Admin only."); return; }
  try {
    await db.collection('app').doc('state').set({
      bettingOpen: false,
      matchActive: false
      // intentionally NOT changing currentMatch
    }, { merge: true });
    alert("App state reset. (bettingOpen=false, matchActive=false)");
  } catch (e) {
    alert("Reset state failed: " + (e?.message || e));
  }
});
// DEBUG: show what the app thinks right now
document.getElementById('debug-status').addEventListener('click', async ()=>{
  try {
    const u = auth.currentUser;
    const uid = u ? u.uid : '(no user)';
    // what the live listeners currently have
    const meCopy = JSON.stringify(__me, null, 2);
    const appCopy = JSON.stringify(window.__appState || {}, null, 2);

    // fetch fresh from Firestore too (in case listener didn‚Äôt attach)
    let userDocData = null;
    let stateDocData = null;
    if (u) {
      const userSnap = await db.collection('users').doc(uid).get();
      userDocData = userSnap.exists ? userSnap.data() : null;
    }
    const stateSnap = await db.collection('app').doc('state').get();
    stateDocData = stateSnap.exists ? stateSnap.data() : null;

    // read current button disabled flags
    const ob = document.getElementById('open-bets');
    const cb = document.getElementById('close-bets');
    const sm = document.getElementById('start-match');
    const em = document.getElementById('end-match');

    const details = [
      `UID: ${uid}`,
      `isAdmin(): ${isAdmin()}`,
      '',
      `__me (listener):\n${meCopy}`,
      '',
      `window.__appState (listener):\n${appCopy}`,
      '',
      `users/${uid} (fresh read):\n${JSON.stringify(userDocData, null, 2)}`,
      '',
      `app/state (fresh read):\n${JSON.stringify(stateDocData, null, 2)}`,
      '',
      `Buttons disabled?`,
      `  Open Bets:  ${ob ? ob.disabled : '(missing)'}  <- disabled if !admin OR bettingOpen`,
      `  Close Bets: ${cb ? cb.disabled : '(missing)'}  <- disabled if !admin OR !bettingOpen`,
      `  Start:      ${sm ? sm.disabled : '(missing)'}  <- disabled if !admin OR matchActive OR bettingOpen`,
      `  End:        ${em ? em.disabled : '(missing)'}  <- disabled if !admin OR !matchActive`,
    ].join('\n');

    alert(details);
  } catch (e) {
    alert('Debug failed: ' + (e?.message || e));
  }
});
document.getElementById('set-match-num').addEventListener('click', async ()=>{
  if (!isAdmin()) { alert("Admin only."); return; }
  const v = prompt("Set the current match number to:", "0");
  if (v === null) return;
  const n = Number(v);
  if (!Number.isInteger(n) || n < 0) { alert("Enter a non-negative integer."); return; }
  try {
    await db.collection('app').doc('state').set({
      currentMatch: n,
      bettingOpen: false,
      matchActive: false
    }, { merge: true });
    alert(`Current match set to ${n}. Betting and match are now closed.`);
  } catch (e) {
    alert('Failed to set match #: ' + (e?.message || e));
  }
});
// Deletes a query's docs in chunks to avoid batch limits
async function deleteQueryInBatches(query, batchSize = 300, label = 'items') {
  let deletedTotal = 0;
  while (true) {
    const snap = await query.limit(batchSize).get();
    if (snap.empty) break;
    const batch = db.batch();
    snap.docs.forEach(doc => batch.delete(doc.ref));
    await batch.commit();
    deletedTotal += snap.size;
    // Small pause so Firestore can catch up
    await new Promise(r => setTimeout(r, 30));
  }
  console.log(`Deleted ${deletedTotal} ${label}.`);
}
document.getElementById('season-reset').addEventListener('click', async ()=>{
  if (!isAdmin()) { alert('Admin only.'); return; }

  const really = confirm(
`‚ö†Ô∏è Season Reset

This will:
‚Ä¢ Reset all users' coins (non-admins) to your baseline
‚Ä¢ Clear MVP leaderboard (mvpScores)
‚Ä¢ Delete ALL past matches, including bets, votes, and MVP results
‚Ä¢ Reset app state (betting closed, match inactive, currentMatch = 0)

Proceed?`
  );
  if (!really) return;

  try {
    // 0) Freeze UI a bit
    alert('Starting season reset‚Ä¶ this can take a moment.');

    // 1) Reset app state
    await db.collection('app').doc('state').set({
      bettingOpen: false,
      matchActive: false,
      currentMatch: 0
    }, { merge: true });

    // 2) Clear MVP leaderboard (delete all docs in mvpScores)
    await deleteQueryInBatches(db.collection('mvpScores'), 300, 'mvpScores');

    // 3) Delete ALL match data: bets, votes, mvpResult, and the match docs
    //    We‚Äôll delete subcollections first via collectionGroup queries,
    //    then delete the top-level match docs themselves.
    await deleteQueryInBatches(db.collectionGroup('bets'),       300, 'bets');
    await deleteQueryInBatches(db.collectionGroup('votes'),      300, 'votes');
    await deleteQueryInBatches(db.collectionGroup('mvpResult'),  300, 'mvpResult');

    // Now delete the /matches/{id} docs (empty containers after subcollections cleared)
    await deleteQueryInBatches(db.collection('matches'), 300, 'match docs');

    // 4) Reset user balances (skip admins)
    const usersSnap = await db.collection('users').get();
    const batchSize = 300;
    let pending = [];
    let wrote = 0;

    usersSnap.forEach(doc => {
      const d = doc.data() || {};
      const isA = d.roles && d.roles.admin === true;

      if (!isA) {
        // Set your desired baseline here:
        pending.push({ ref: doc.ref, data: { coins: 100, availableCoins: 0 } });
      }
    });

    while (pending.length) {
      const chunk = pending.splice(0, batchSize);
      const b = db.batch();
      chunk.forEach(item => b.set(item.ref, item.data, { merge: true }));
      await b.commit();
      wrote += chunk.length;
      await new Promise(r => setTimeout(r, 30));
    }
    console.log(`Reset balances for ${wrote} player(s).`);

    alert('‚úÖ Season reset complete.\n\nCoins reset, MVP leaderboard cleared, and all match/bet/vote history removed.');
  } catch (e) {
    alert('Season reset failed: ' + (e && e.message ? e.message : e));
  }
});
</script>
</body>
</html>
