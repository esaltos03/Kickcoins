<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kickcoins - Fantasy Betting</title>
<style>
/* --- STYLES SAME AS ORIGINAL --- */
body { font-family: Arial, sans-serif; background-color: #121212; color: #fff; margin:0; padding:0; }
header { display:flex; justify-content:space-between; align-items:center; padding:10px 20px; background-color:#1a1a1a; }
header .account { display:flex; align-items:center; gap:15px; }
.tabs { display:flex; background-color:#1a1a1a; }
.tab { flex:1; padding:10px; text-align:center; cursor:pointer; border-bottom:2px solid #121212; }
.tab.active { border-bottom:2px solid #00ff00; }
main { padding:20px; }
.card { background-color:#1f1f1f; padding:15px; margin:10px 0; border-radius:8px; }
.prop { display:flex; justify-content:space-between; align-items:center; margin:10px 0; }
.prop input[type="number"] { width:50px; margin-left:10px; }
select { padding:5px; }
button { padding:5px 10px; cursor:pointer; border:none; border-radius:5px; }
button:disabled { background-color: #555; cursor: not-allowed; }
.green { color:#00ff00; }
.red { color:#ff0000; }
table { width:100%; border-collapse:collapse; }
th, td { padding:8px; text-align:left; border-bottom:1px solid #333; }
#login-card { max-width:400px; margin:50px auto; }
.bet-payout { margin-left:10px; font-weight:bold; }
.match-card {
    background-color: #1f1f1f; /* Slightly different from page */
    padding: 10px 15px;
    margin-bottom: 15px;
    border-radius: 8px;
    border: 1px solid #333; /* subtle outline */
    box-shadow: 0 2px 4px rgba(0,0,0,0.3); /* optional subtle shadow */
}
.match-card strong {
    display: block;
    margin-bottom: 8px;
    font-size: 1.1em;
}
.match-card ul {
    padding-left: 20px;
    margin: 0;
}
.match-card div.total {
    margin-top: 8px;
}
.mvp-card {
    background-color: #1f1f1f;
    padding: 10px 15px;
    margin-bottom: 15px;
    border-radius: 8px;
    border: 1px solid #333;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
.mvp-card strong {
    display: block;
    margin-bottom: 8px;
    font-size: 1.1em;
}
.mvp-card div.result {
    padding-left: 20px;
    margin: 2px 0;
}
/* Admin resolve bets styling */
.resolve-bet {
    background-color: #1f1f1f;
    padding: 10px;
    margin: 10px 0;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.resolve-bet-info {
    font-weight: bold;
    color: #fff;
    margin-bottom: 5px;
}

.resolve-buttons {
    display: flex;
    gap: 15px;
}

.resolve-buttons button {
    padding: 8px 20px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    font-weight: bold;
}

.resolve-buttons button.win {
    background-color: #00ff00;
    color: #000;
}

.resolve-buttons button.lose {
    background-color: #ff0000;
    color: #fff;
}
.admin-bet-card { margin: 10px 0; padding: 10px; background-color:#1f1f1f; border-radius:8px; }
.admin-win-btn { background-color: #00ff00; color: #000; margin-right: 10px; padding:5px 12px; font-weight:bold; cursor:pointer; border:none; border-radius:5px; }
.admin-lose-btn { background-color: #ff0000; color: #000; padding:5px 12px; font-weight:bold; cursor:pointer; border:none; border-radius:5px; }
.total-coins {
    font-weight: bold;
    background-color: #222;   /* Slightly different from card */
    padding: 5px 10px;
    border-radius: 5px;
    margin-top: 8px;
}
/* Admin section cleanup */
.admin-section {
  background: #1e1e1e;
  border-radius: 8px;
  padding: 15px;
  margin-bottom: 20px;
}

.admin-section h3 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 18px;
  color: #fff;
}

.tag-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.tag {
  background: #2c2c2c;
  padding: 5px 10px;
  border-radius: 20px;
  color: #fff;
  font-size: 14px;
  display: flex;
  align-items: center;
}

.tag button {
  margin-left: 8px;
  background: #ff4d4d;
  border: none;
  border-radius: 50%;
  width: 18px;
  height: 18px;
  font-size: 12px;
  cursor: pointer;
  color: white;
}
</style>
<!-- Firebase (compat build for Auth) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
</head>
<body>

<header>
<h1>Kickcoins ⚽</h1>
<div class="account" id="account-info"></div>
<button id="logout-btn" style="display:none;">Logout</button>
</header>

<div id="login-card" class="card">
<h2>Login / Create Account</h2>
<label>Username:</label><input type="text" id="login-username"><br><br>
<label>Password:</label><input type="password" id="login-password"><br><br>
<button id="login-btn">Login</button>
<button id="create-btn">Create Account</button>
</div>

<div id="app" style="display:none;">
<div class="tabs">
    <div class="tab active" data-tab="vote">MVP Voting</div>
    <div class="tab" data-tab="bet">Betting</div>
    <div class="tab" data-tab="leaderboard">Leaderboards</div>
    <div class="tab" data-tab="history">Bet History</div>
    <div class="tab" data-tab="admin">Admin</div>
</div>

<main>
<!-- MVP Voting -->
<div class="tab-content" id="vote-tab">
    <div class="card">
        <h2>Vote for MVP</h2>
        <label>1st Place:</label>
        <select id="vote1"></select>
        <label>2nd Place:</label>
        <select id="vote2"></select>
        <label>3rd Place:</label>
        <select id="vote3"></select>
        <button id="submit-votes">Submit Votes</button>
    </div>
</div>

<!-- Betting -->
<div class="tab-content" id="bet-tab" style="display:none;">
    <div class="card">
        <h2>Betting</h2>
        <div id="balance-display"></div>
        <label>Select Player:</label>
        <select id="player-select"></select>
        <div id="props-container"></div>
        <div>Total Potential Payout: <span id="total-payout" class="bet-payout">0</span></div>
        <button id="submit-bets">Place Bets</button>
    </div>
</div>

<!-- Leaderboards -->
<div class="tab-content" id="leaderboard-tab" style="display:none;">
    <div class="card">
        <h2>Overall MVP Leaderboard</h2>
        <table id="mvp-leaderboard">
            <thead><tr><th>Place</th><th>Player</th><th>Points</th></tr></thead>
            <tbody></tbody>
        </table>
    </div>
    <div class="card">
        <h2>MVP History per Match</h2>
        <div id="mvp-history"></div>
    </div>
</div>

<!-- Bet History -->
<div class="tab-content" id="history-tab" style="display:none;">
    <div class="card">
        <h2>Betting Leaderboard</h2>
        <table id="coin-leaderboard">
            <thead><tr><th>Place</th><th>Player</th><th>Coins</th><th>Admin</th></tr></thead>
            <tbody></tbody>
        </table>
    </div>
    <div class="card" id="history-container"></div>
</div>

<!-- Admin -->
<div class="tab-content" id="admin-tab" style="display:none;">
    <div class="card">
        <h2>Admin Controls</h2>
        <button id="open-bets">Open Betting</button>
        <button id="close-bets" disabled>Close Betting</button>
        <button id="start-match" disabled>Start Match</button>
        <button id="end-match" disabled>End Match</button>
        <div id="resolve-bets"></div>
    </div>
    <div class="card">
<h2>Manage Betting Props</h2>

<!-- Admin props area: left = players/entity controls, right = add prop + current props -->
<div class="admin-section" style="display:flex; gap:20px; flex-wrap:wrap; align-items:flex-start;">

  <!-- Left column: player select + entity (player) management (JS will create entity controls if missing) -->
  <div style="min-width:260px; width:260px;">
    <label style="display:block; margin-bottom:6px;">Player:</label>
    <select id="prop-player" style="width:100%; padding:6px; margin-bottom:8px;"></select>

    <!-- NOTE: Do NOT remove this area — renderEntityList() may create or update #entity-list -->
    <div id="players-list-wrapper" style="margin-top:8px;">
      <small style="opacity:0.8;">Players (use remove buttons):</small>
      <div id="entity-list" style="margin-top:8px;"></div>
    </div>
  </div>

  <!-- Right column: add prop & props list -->
  <div style="flex:1; min-width:300px;">
    <label style="display:block; margin-bottom:6px;">Add Prop</label>
    <input type="text" id="new-prop" placeholder="Enter prop name" style="padding:6px; width:60%;" />
    <input type="number" id="new-odds" placeholder="Odds (x)" min="1" style="padding:6px; width:30%; margin-left:6px;" />
    <button id="add-prop" type="button" style="display:block; margin-top:8px; padding:6px 8px;">Add Prop</button>

    <div style="margin-top:12px;">
      <h4 style="margin:6px 0;">Current Props</h4>
      <div id="props-list"></div>
    </div>
  </div>
</div>
</div>

<div class="admin-section">
  <h3>Current Players</h3>
  <div id="players-container" class="tag-list"></div>
</div>
    </div>
    <div class="card">
  <h2>Admin Tests</h2>
  <button id="clear-votes">Clear Mvp Votes</button>
  <button id="promote-me" style="margin-left:10px;">Make Me Admin (temp)</button>
</div>
</div>
</main>

<script>
// ------------------ STORAGE ------------------
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyAjq_4nylYza2VDiiT6KJq9VZ7auMe7gxo",
  authDomain: "kickcoins-v3.firebaseapp.com",
  projectId: "kickcoins-v3",
  storageBucket: "kickcoins-v3.appspot.com", // <-- FIXED
  messagingSenderId: "601991069210",
  appId: "1:601991069210:web:422a5389bcc9dd62845ba3",
  measurementId: "G-16L5MNM4E5"
};

// Initialize Firebase (exactly once)
firebase.initializeApp(firebaseConfig);

// Initialize services AFTER app init
const auth = firebase.auth();
const db   = firebase.firestore();
    // --- DIAG STEP 1A: check project details ---
setTimeout(()=>{
  const opts = firebase.app().options || {};
  alert(
    'Project: ' + (opts.projectId || '(none)') +
    '\nAuth domain: ' + (opts.authDomain || '(none)')
  );
}, 0);
    window.addEventListener('error', (e) => {
  alert('JS Error: ' + (e && e.message ? e.message : String(e)));
});
if(!localStorage.getItem('kickcoinsUsers')){
    var users = {
        "Erick": { password:"pass", totalCoins:100, availableCoins:0, votesThisMatch:{}, bets:[], mvpPoints:0, history:[], voted:false },
        "Yansy": { password:"pass", totalCoins:100, availableCoins:0, votesThisMatch:{}, bets:[], mvpPoints:0, history:[], voted:false },
        "admin": { password:"KickCoins123", isAdmin:true, totalCoins:0, availableCoins:0, votesThisMatch:{}, bets:[], mvpPoints:0, history:[], voted:false }
    };
    localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
}else{
    var users = JSON.parse(localStorage.getItem('kickcoinsUsers'));
}

const players = ["Erick","Yansy","Bernie","Erubial","Samir","Angel","Abel","Estress","Alan","Byron"];
let propEntities = localStorage.getItem('propEntities') ? JSON.parse(localStorage.getItem('propEntities')) : [...players];
let mvpScores = localStorage.getItem('mvpScores') ? JSON.parse(localStorage.getItem('mvpScores')) : {};
players.forEach(p=>{ if(!mvpScores[p]) mvpScores[p]=0; });

let propsTemplate = localStorage.getItem('propsTemplate') ? JSON.parse(localStorage.getItem('propsTemplate')) : {};
propEntities.forEach(p=>{
    if(!propsTemplate[p]) propsTemplate[p] = [{name:"Score", odds:4},{name:"Assist", odds:3},{name:"Anything", odds:2}];
});
localStorage.setItem('propsTemplate', JSON.stringify(propsTemplate));

let mvpHistory = localStorage.getItem('mvpHistory') ? JSON.parse(localStorage.getItem('mvpHistory')) : [];
let currentMatch = localStorage.getItem('currentMatch') ? parseInt(localStorage.getItem('currentMatch')) : 0;

let currentUser=null;
let myBetsUnsub = null; // live listener for "My Bets" (Firestore)

// ------------------ LOGIN ------------------
// ------------------ FIREBASE LOGIN / CREATE / LOGOUT ------------------

// Toggle login vs app UI
function showLogin(show=true){
    document.getElementById('login-card').style.display = show ? 'block' : 'none';
    document.getElementById('app').style.display = !show ? 'block' : 'none';
    document.getElementById('logout-btn').style.display = !show ? 'inline' : 'none';
}

// Helper: convert username to fake email
function usernameToEmail(username){
    return username + "@kickcoins.com";
}

// LOGIN
document.getElementById('login-btn').addEventListener('click', async ()=>{
    const username = document.getElementById('login-username').value.trim();
    const pass = document.getElementById('login-password').value;
    if(!username || !pass){ alert("Enter username and password."); return; }
    try {
        const email = usernameToEmail(username);
        await auth.signInWithEmailAndPassword(email, pass);
        currentUser = username;
        if(!users[username]){
            users[username] = { password:pass, totalCoins:100, availableCoins:0, votesThisMatch:{}, bets:[], mvpPoints:0, history:[], voted:false };
            localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
        }
        showLogin(false);
        updateUI(); populateVoting(); populatePlayers(); updateLeaderboards(); updateHistory(); populatePropAdmin();
        alert("Logged in!");
    } catch(err){ alert("Login failed: " + err.message); }
});

// CREATE
// CREATE (allows create even if local user exists)
document.getElementById('create-btn').addEventListener('click', async ()=>{
  const username = document.getElementById('login-username').value.trim();
  const pass = document.getElementById('login-password').value;
  if(!username || !pass){ alert("Enter username and password."); return; }

  const email = usernameToEmail(username);

  try {
    // Try to create in Firebase Auth
    const cred = await auth.createUserWithEmailAndPassword(email, pass);
    await cred.user.updateProfile({ displayName: username });

    // Ensure local mirror exists (keeps rest of UI happy for now)
    if(!users[username]){
      users[username] = { password:pass, totalCoins:100, availableCoins:0, votesThisMatch:{}, bets:[], mvpPoints:0, history:[], voted:false };
      localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
    }

    currentUser = username;
    showLogin(false);
    updateUI(); populateVoting(); populatePlayers(); updateLeaderboards(); updateHistory(); populatePropAdmin();
    alert("Account created & logged in!");
  } catch(err){
    if (err && err.code === 'auth/email-already-in-use') {
      // If account exists in Firebase, just sign in instead
      try {
        await auth.signInWithEmailAndPassword(email, pass);
        currentUser = username;
        if(!users[username]){
          users[username] = { password:pass, totalCoins:100, availableCoins:0, votesThisMatch:{}, bets:[], mvpPoints:0, history:[], voted:false };
          localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
        }
        showLogin(false);
        updateUI(); populateVoting(); populatePlayers(); updateLeaderboards(); updateHistory(); populatePropAdmin();
        alert("Logged in!");
      } catch(signInErr){
        alert("Signup/Login failed: " + signInErr.message);
      }
    } else {
      alert("Signup failed: " + err.message);
    }
  }
});

// LOGOUT
document.getElementById('logout-btn').addEventListener('click', async ()=>{
    try { await auth.signOut(); currentUser=null; showLogin(true); }
    catch(err){ alert("Logout failed: " + err.message); }
});

// React to Firebase login state changes (SAFE VERSION)
auth.onAuthStateChanged(async (user) => {
  if (!user) {
    currentUser = null;
    showLogin(true);
    alert('AUTH: not signed in');
    return;
  }

  // Derive username from displayName or from email before "@"
  const username = (user.displayName && user.displayName.trim())
    ? user.displayName.trim()
    : (user.email ? user.email.split("@")[0] : "user");
  currentUser = username;

  try {
    const uid = user.uid;
    const userRef = db.collection('users').doc(uid);

    // Read FIRST; only create minimal fields if doc is missing (do NOT touch roles)
    let snap = await userRef.get();
    if (!snap.exists) {
      await userRef.set({
        email: user.email || null,
        username: username,
        coins: 100,
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge: true });
      snap = await userRef.get();
    }

    const data = snap.exists ? snap.data() : {};
    const adminVal = data && data.roles ? data.roles.admin : undefined;

    // Keep while debugging; remove later if you want
    alert(
      'AUTH: signed in' +
      '\nUID: ' + uid +
      '\nDoc exists: ' + snap.exists +
      '\nroles.admin: ' + String(adminVal) + ' (type: ' + typeof adminVal + ')'
    );

    // Keep local model happy + sync admin flag from Firestore
    if (!users[username]) {
      users[username] = { password: "", totalCoins: 100, availableCoins: 0, votesThisMatch: {}, bets: [], mvpPoints: 0, history: [], voted: false };
    }
    users[username].isAdmin = (adminVal === true);
    localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
      // === LIVE BALANCE LISTENER FOR SIGNED-IN USER ===
if (window.__userUnsub) { try { window.__userUnsub(); } catch(_){} }
window.__userUnsub = db.collection('users').doc(user.uid).onSnapshot((doc) => {
  const d = doc.exists ? doc.data() : {};
  // fallbacks so we don't crash on undefined
  const totalCoins = typeof d.coins === 'number' ? d.coins : 100;
  const available = typeof d.availableCoins === 'number' ? d.availableCoins : 0;

  // keep the local mirror just for rendering that header/UI
  if (!users[username]) users[username] = {};
  users[username].totalCoins = totalCoins;
  users[username].availableCoins = available;
  localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
  updateUI();
});
  } catch (e) {
    alert('AUTH DIAG error: ' + (e && e.message ? e.message : String(e)));
  }

  // Proceed with your UI
  showLogin(false);
  updateUI();
  populateVoting();
  populatePlayers();
  updateLeaderboards();
  updateHistory();
  populatePropAdmin();
});
// ---------- FIRESTORE APP STATE ----------
const stateRef = db.collection('app').doc('state');

// Ensure the state doc exists once (safe to call always)
async function ensureState() {
  const snap = await stateRef.get();
  if (!snap.exists) {
    await stateRef.set({ bettingOpen: false, matchActive: false, currentMatch: 0 });
  }
}
ensureState();

// Real-time listener to reflect buttons & keep local mirror in sync
stateRef.onSnapshot((snap) => {
  if (!snap.exists) return;
  const st = snap.data();
  window.__appState = st;

  // keep your local currentMatch in sync for the parts still using it
  if (typeof currentMatch !== 'undefined') currentMatch = Number(st.currentMatch || 0);

  // Admin button enable/disable (guard if elements exist)
  const ob = document.getElementById('open-bets');
  const cb = document.getElementById('close-bets');
  const sm = document.getElementById('start-match');
  const em = document.getElementById('end-match');

  const userIsAdmin = (currentUser && users[currentUser] && users[currentUser].isAdmin) ? true : false;

  if (ob) ob.disabled = !userIsAdmin || !!st.bettingOpen;
  if (cb) cb.disabled = !userIsAdmin || !st.bettingOpen;
  if (sm) sm.disabled = !userIsAdmin || !!st.matchActive || !!st.bettingOpen;
  if (em) em.disabled = !userIsAdmin || !st.matchActive;

  // 🔴 NEW LINE: attach/update the live "My Bets" listener for this match
  maybeAttachMyBetsListener(Number(st.currentMatch || 0));
});
// ------------------ TAB NAV ------------------
document.querySelectorAll('.tab').forEach(tab=>{
    tab.addEventListener('click',()=>{
        document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
        tab.classList.add('active');
        document.querySelectorAll('.tab-content').forEach(tc=>tc.style.display='none');
        document.getElementById(tab.dataset.tab+'-tab').style.display='block';
        updateUI(); if(tab.dataset.tab==="history") updateHistory();
        if(tab.dataset.tab==="admin" && currentUser && users[currentUser].isAdmin) renderPropsList();
    });
});

// ------------------ ACCOUNT DISPLAY ------------------
function updateUI(){
    if(!currentUser) return;
    let acc=users[currentUser];
    document.getElementById('account-info').innerHTML=`${currentUser} | Total: ${acc.totalCoins} 💰 | Available: ${acc.availableCoins} 💸`;
    localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
    // Admin tab visibility
    const adminTab = document.querySelector('.tab[data-tab="admin"]');
    const adminContent = document.getElementById('admin-tab');
    if(users[currentUser].isAdmin){
        adminTab.style.display = "block";
    }else{
        adminTab.style.display = "none"; adminContent.style.display = "none";
        if(document.querySelector(".tab.active").dataset.tab === "admin"){
            document.querySelector('.tab[data-tab="vote"]').click();
        }
    }
}

// ------------------ MVP VOTING ------------------
function populateVoting(){
    ["vote1","vote2","vote3"].forEach(id=>{
        let sel=document.getElementById(id); sel.innerHTML="";
        players.forEach(p=>{
            let opt=document.createElement("option"); opt.value=p; opt.text=p; sel.appendChild(opt);
        });
    });
}
document.getElementById('submit-votes').addEventListener('click',()=>{
    const st = window.__appState || {};
if(!st.matchActive){ alert("Match not started yet."); return; }
    if(users[currentUser].voted){ alert("Already voted."); return; }
    let first=document.getElementById('vote1').value;
    let second=document.getElementById('vote2').value;
    let third=document.getElementById('vote3').value;
    if(new Set([first,second,third]).size<3){ alert("Cannot vote same player multiple times."); return; }
    users[currentUser].votesThisMatch={"1st":first,"2nd":second,"3rd":third};
    users[currentUser].voted=true;
    localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
    alert("Votes submitted!");
    updateLeaderboards();
});

// ------------------ BETTING ------------------
function populatePlayers(){
    let sel=document.getElementById('player-select'); sel.innerHTML="";
    propEntities.forEach(p=>{
        let opt=document.createElement("option"); opt.value=p; opt.text=p; sel.appendChild(opt);
    });
    sel.addEventListener('change', populateProps);
}
function populateProps(){
    let container=document.getElementById('props-container'); container.innerHTML="";
    let player=document.getElementById('player-select').value;
    propsTemplate[player].forEach(prop=>{
        let card=document.createElement("div"); card.className="prop";
        let label=document.createElement("span"); label.textContent=`${prop.name} (${prop.odds}x)`; label.className="green";
        let input=document.createElement("input"); input.type="number"; input.min=0; input.max=users[currentUser].availableCoins; input.dataset.odds=prop.odds;
        input.oninput=updatePotentialPayout;
        card.appendChild(label); card.appendChild(input); container.appendChild(card);
    });
    updatePotentialPayout();
}
function updatePotentialPayout(){
    const container=document.getElementById('props-container');
    let total=0;
    for(let p of container.children){
        let input=p.querySelector('input'); let amt=Number(input.value); let odds=Number(input.dataset.odds);
        if(amt>0){ total += amt*odds + amt; }
    }
    const payoutDisplay=document.getElementById('total-payout');
    payoutDisplay.textContent=total; payoutDisplay.style.color=total>50?'green':'yellow';
}
document.getElementById('submit-bets').addEventListener('click', async ()=>{
  try {
    const st = window.__appState || {};
    if (!st.bettingOpen) { alert('Betting not open.'); return; }

    const u = auth.currentUser;
    if (!u) { alert('Not signed in.'); return; }

    const username = currentUser;
    const userDocRef = db.collection('users').doc(u.uid);

    // Collect bet inputs from the UI
    const container = document.getElementById('props-container');
    const player = document.getElementById('player-select').value;

    // Build an array of {propName, odds, amount} from the inputs
    const entries = [];
    for (let node of container.children) {
      const label = node.querySelector('span')?.textContent || '';
      const input = node.querySelector('input');
      if (!input) continue;
      const amt = Number(input.value || 0);
      const odds = Number(input.dataset.odds || 0);
      if (amt > 0 && odds > 0) {
        entries.push({
          propName: label.split(' (')[0], // "Score (4x)" -> "Score"
          odds,
          amount: amt
        });
      }
    }

    if (entries.length === 0) {
      alert('Enter at least one bet amount.');
      return;
    }

    // Sum up total to deduct
    const totalStake = entries.reduce((s, e) => s + e.amount, 0);

    // Do everything atomically
    await db.runTransaction(async (tx) => {
      // 1) Check app state
      const stateSnap = await tx.get(stateRef);
      if (!stateSnap.exists) throw new Error('App state missing.');
      const state = stateSnap.data() || {};
      const currentMatch = Number(state.currentMatch || 0);
      if (!state.bettingOpen) throw new Error('Betting is not open.');

      // 2) Check user funds
      const userSnap = await tx.get(userDocRef);
      if (!userSnap.exists) throw new Error('User profile missing.');
      const d = userSnap.data() || {};
      const avail = Number(d.availableCoins || 0);
      if (totalStake > avail) throw new Error('Insufficient available coins.');

      // 3) Create bet docs under the current match
      const betsCol = db.collection('matches').doc(String(currentMatch)).collection('bets');
      const now = firebase.firestore.FieldValue.serverTimestamp();

      entries.forEach((e) => {
        const betRef = betsCol.doc(); // auto id
        tx.set(betRef, {
          uid: u.uid,
          username: username,
          match: currentMatch,
          player: player,
          prop: e.propName,
          odds: e.odds,
          amount: e.amount,
          resolved: false,
          won: false,
          createdAt: now
        });
      });

      // 4) Deduct availableCoins
      tx.update(userDocRef, {
        availableCoins: avail - totalStake
      });
    });

    // Clear inputs + refresh UI
    for (let node of document.getElementById('props-container').children) {
      const input = node.querySelector('input');
      if (input) input.value = '';
    }
    updatePotentialPayout();
    alert('Bets placed!');

  } catch (err) {
    alert('Place bets failed: ' + (err && err.message ? err.message : String(err)));
  }
});
// ------------------ ADMIN BET CONTROL ------------------
document.getElementById('open-bets').addEventListener('click', async ()=>{
  if (!currentUser || !users[currentUser]?.isAdmin) return;

  try {
    // 1) Flip app state (increment match, open betting, ensure match not active)
    await stateRef.set({
      bettingOpen: true,
      matchActive: false,
      currentMatch: firebase.firestore.FieldValue.increment(1)
    }, { merge: true });

    // 2) Give coins to all non-admin users (batch for speed)
    const usersSnap = await db.collection('users').get();
    const batch = db.batch();
    usersSnap.forEach(doc => {
      const d = doc.data() || {};
      const isAdmin = d.roles && d.roles.admin === true;
      if (isAdmin) return;

      const total = typeof d.coins === 'number' ? d.coins : 100;
      const avail = typeof d.availableCoins === 'number' ? d.availableCoins : 0;

      // same logic you had locally:
      const grant = Math.min(10, total);       // cannot grant more than they have
      const newTotal = total - grant;
      const newAvail = avail + grant;

      batch.set(doc.ref, {
        coins: newTotal,
        availableCoins: newAvail,
        voted: false // optional: clears voted for new match, like before
      }, { merge: true });
    });
    await batch.commit();

    alert('Betting opened and balances granted.');
  } catch (e) {
    alert('Open betting failed: ' + (e && e.code ? e.code + ' - ' : '') + (e && e.message ? e.message : e));
  }
});
  // We will handle coins later when we move coins to Firestore.
document.getElementById('close-bets').addEventListener('click', async ()=>{
  if (!currentUser || !users[currentUser]?.isAdmin) return;

  try {
    // 1) Flip app state
    await stateRef.set({ bettingOpen: false }, { merge: true });

    // 2) Zero availableCoins for all non-admins (only if needed) and count how many were changed
    const usersSnap = await db.collection('users').get();
    const batch = db.batch();
    let touched = 0;

    usersSnap.forEach(doc => {
      const d = doc.data() || {};
      const isAdmin = d.roles && d.roles.admin === true;
      if (isAdmin) return;

      const currentAvail = typeof d.availableCoins === 'number' ? d.availableCoins : 0;
      if (currentAvail !== 0) {
        batch.set(doc.ref, { availableCoins: 0 }, { merge: true });
        touched++;
      }
    });

    if (touched > 0) {
      await batch.commit();
    }

    alert('Betting closed. Zeroed availableCoins for ' + touched + ' user(s).');
  } catch (e) {
    alert('Close betting failed: ' + (e && e.code ? e.code + ' - ' : '') + (e && e.message ? e.message : e));
  }
});
document.getElementById('start-match').addEventListener('click', async ()=>{
  if (!currentUser || !users[currentUser]?.isAdmin) return;
  try {
    await stateRef.update({ matchActive: true });
    reviewBetsForAdmin(); // keep your UI function
    alert('Match started.');
  } catch (e) {
    alert('Start match failed: ' + (e && e.message ? e.message : e));
  }
});
document.getElementById('end-match').addEventListener('click', async ()=>{
  if (!currentUser || !users[currentUser]?.isAdmin) return;
  try {
    await stateRef.update({ matchActive: false });
    // keep your local MVP tally for now
    let matchResult={match:currentMatch, results:[]};
    Object.keys(users).forEach(u=>{
      let v=users[u].votesThisMatch;
      if(v["1st"]) { mvpScores[v["1st"]]+=5; matchResult.results.push({player:v["1st"],points:5,place:"1st"}); }
      if(v["2nd"]) { mvpScores[v["2nd"]]+=3; matchResult.results.push({player:v["2nd"],points:3,place:"2nd"}); }
      if(v["3rd"]) { mvpScores[v["3rd"]]+=2; matchResult.results.push({player:v["3rd"],points:2,place:"3rd"}); }
      users[u].votesThisMatch={}; users[u].voted=false;
    });
    mvpHistory.push(matchResult);
    localStorage.setItem('mvpScores', JSON.stringify(mvpScores));
    localStorage.setItem('mvpHistory', JSON.stringify(mvpHistory));
    updateLeaderboards(); updateUI();
    alert('Match ended.');
  } catch (e) {
    alert('End match failed: ' + (e && e.message ? e.message : e));
  }
});

// ------------------ REVIEW & RESOLVE BETS ------------------
// ------------------ REVIEW & RESOLVE BETS ------------------
function reviewBetsForAdmin(){
    const resolveDiv = document.getElementById('resolve-bets');
    resolveDiv.innerHTML="<h3>Resolve Bets</h3>";

    // Collect all unresolved bets across users
    let allBets = [];
    Object.keys(users).forEach(u=>{
        if(!users[u].isAdmin){
            users[u].bets.filter(b=>!b.resolved).forEach(bet=>{
                allBets.push({username:u, player:bet.player, prop:bet.prop, amount:bet.amount, odds:bet.odds, betObj:bet});
            });
        }
    });

    // Deduplicate bets by player + prop + odds
    let uniqueBetsMap = {};
    allBets.forEach(b=>{
        let key = `${b.player}||${b.prop}||${b.odds}`;
        if(!uniqueBetsMap[key]) uniqueBetsMap[key] = [];
        uniqueBetsMap[key].push(b);
    });

    // Render unique bets
    Object.entries(uniqueBetsMap).forEach(([key, betGroup])=>{
        const sampleBet = betGroup[0]; // take first as sample
        const div=document.createElement('div');
        div.className = "admin-bet-card";
        div.innerHTML=`${sampleBet.player} - ${sampleBet.prop} | Odds: ${sampleBet.odds}x | Amounts: ${betGroup.map(b=>b.amount).join(', ')}`;
        
        const winBtn=document.createElement('button'); 
        winBtn.textContent="Win"; 
        winBtn.className="admin-win-btn";
        const loseBtn=document.createElement('button'); 
        loseBtn.textContent="Lose"; 
        loseBtn.className="admin-lose-btn";

        // Resolving applies to all users who made this bet
        winBtn.onclick = ()=>{ betGroup.forEach(b=>resolveBet(b.username, b.betObj, true)); div.remove(); };
        loseBtn.onclick = ()=>{ betGroup.forEach(b=>resolveBet(b.username, b.betObj, false)); div.remove(); };

        div.appendChild(winBtn); 
        div.appendChild(loseBtn);
        resolveDiv.appendChild(div);
    });
}

function resolveBet(username, bet, won){
    if(bet.resolved) return; // safety
    bet.resolved=true;
    bet.won=won;
    if(won){
        let payout = bet.amount * bet.odds + bet.amount;
        users[username].totalCoins += payout;
    }
    updateUI();
    updateHistory();
    updateLeaderboards();
    localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
}

// ------------------ LEADERBOARDS ------------------
function updateLeaderboards(){
    let tbody=document.getElementById('mvp-leaderboard').querySelector('tbody'); tbody.innerHTML="";
    Object.entries(mvpScores).sort((a,b)=>b[1]-a[1]).forEach((entry,i)=>{
        let tr=document.createElement("tr");
        let icon=i===0?'🥇':i===1?'🥈':i===2?'🥉':i<7?'🪨':'🍆';
        tr.innerHTML=`<td>${i+1} ${icon}</td><td>${entry[0]}</td><td>${entry[1]}</td>`; tbody.appendChild(tr);
    });
    const mh=document.getElementById('mvp-history'); mh.innerHTML="";
mvpHistory.forEach(m=>{
    let div=document.createElement("div"); div.className="mvp-card";
    div.innerHTML = `<strong>Match ${m.match}</strong>`;
    m.results.forEach(r=>{
        let emoji = '';
        switch(r.points){
            case 5: emoji='🥇'; break;
            case 3: emoji='🥈'; break;
            case 2: emoji='🥉'; break;
            default: 
                emoji = r.points >= 1 && r.points <= 7 ? '🪨' : '🍆';
        }
        let resDiv = document.createElement('div');
        resDiv.className='result';
        resDiv.textContent = `${emoji} ${r.place}: ${r.player} (+${r.points})`;
        div.appendChild(resDiv);
    });
    mh.appendChild(div);
});
    let ct=document.getElementById('coin-leaderboard').querySelector('tbody'); ct.innerHTML="";
    Object.entries(users).filter(u=>!users[u[0]].isAdmin).sort((a,b)=>b[1].totalCoins-a[1].totalCoins).forEach((entry,i)=>{
        let tr=document.createElement("tr");
        let delBtn=users[currentUser]&&users[currentUser].isAdmin?`<button onclick="deleteUser('${entry[0]}')">Delete</button>`:"";
        let icon=i===0?'🥇':i===1?'🥈':i===2?'🥉':i<7?'🪨':'🍆';
        tr.innerHTML=`<td>${i+1} ${icon}</td><td>${entry[0]}</td><td>${entry[1].totalCoins}</td><td>${delBtn}</td>`; ct.appendChild(tr);
    });
}

// ------------------ HISTORY ------------------
function updateHistory(){
    const container = document.getElementById('history-container'); 
    container.innerHTML = "";
    if(!currentUser) return;

    // Group bets by match
    const betsByMatch = {};
    users[currentUser].bets.forEach(bet => {
        if(!betsByMatch[bet.match]) betsByMatch[bet.match] = [];
        betsByMatch[bet.match].push(bet);
    });

    Object.keys(betsByMatch).sort((a,b)=>b-a).forEach(matchNum => {
        const matchBets = betsByMatch[matchNum];

        // Create match card
        const matchDiv = document.createElement("div");
        matchDiv.className = "match-card";

        // Match header
        const header = document.createElement("strong");
        header.textContent = `Match ${matchNum}`;
        matchDiv.appendChild(header);

        // List of bets
        const ul = document.createElement("ul");
        let totalBet = 0, totalWon = 0;

        matchBets.forEach(bet => {
    const li = document.createElement("li");

    // If resolved, show Won/Lost; if not, show Pending
    li.textContent = `${bet.player} - ${bet.prop} (${bet.odds}x) | Amount: ${bet.amount} | Resolved: ${bet.resolved} | ${bet.resolved ? (bet.won ? "Won" : "Lost") : "Pending"}`;

    // Set color based on status
    if(!bet.resolved) li.style.color = "yellow";       // pending
    else li.style.color = bet.won ? "green" : "red";   // resolved

    ul.appendChild(li);

    // Total calculations only count resolved bets
    totalBet += bet.amount;
    if(bet.resolved && bet.won) totalWon += bet.amount * bet.odds + bet.amount;
});

        matchDiv.appendChild(ul);

        // Total bet/won line
        const totalDiv = document.createElement("div");
totalDiv.className = "total total-coins";  // added total-coins class
totalDiv.textContent = `Total Coins Bet: ${totalBet} | Total Coins Won: ${totalWon}`;

// Optional: keep color coding
if(totalWon < 10) totalDiv.style.color = "red";
else if(totalWon === 10) totalDiv.style.color = "yellow";
else totalDiv.style.color = "green";

matchDiv.appendChild(totalDiv);

        container.appendChild(matchDiv);
    });
}

// ------------------ ADMIN PROP MANAGEMENT ------------------
function populatePropAdmin(){
    let sel = document.getElementById('prop-player'); 
    sel.innerHTML = "";

    propEntities.forEach(p=>{ 
        let opt = document.createElement("option"); 
        opt.value = p; 
        opt.text = p; 
        sel.appendChild(opt); 
    });

    renderPropsList();  // Render props for selected player
    renderEntityList(); // Render list of players

    // --- ADD ENTITY MANAGEMENT CONTROLS ---
    let entityContainer = document.getElementById('prop-entity-container');
    if(!entityContainer){
        entityContainer = document.createElement('div');
        entityContainer.id = 'prop-entity-container';
        entityContainer.style.margin = "10px 0";

        let input = document.createElement('input');
        input.type = 'text';
        input.id = 'new-entity';
        input.placeholder = 'Enter new player';
        input.style.margin = "0px 0px 10px 0px"
        input.style.padding = "6px";

        let addBtn = document.createElement('button');
        addBtn.textContent = 'Add Player';
        addBtn.onclick = ()=>{
            let name = input.value.trim();
            if(name && !propEntities.includes(name)){
                propEntities.push(name);
                // initialize default props
                propsTemplate[name] = [
                    {name:"Score", odds:4},
                    {name:"Assist", odds:3},
                    {name:"Anything", odds:2}
                ];
                localStorage.setItem('propEntities', JSON.stringify(propEntities));
                localStorage.setItem('propsTemplate', JSON.stringify(propsTemplate));
                input.value="";
                populatePropAdmin(); // re-render everything
                populatePlayers();    // update betting dropdown
            }
        };

        entityContainer.appendChild(input);
        entityContainer.appendChild(addBtn);
        sel.parentNode.insertBefore(entityContainer, sel.nextSibling);
    }
}

function renderEntityList(){
    let container = document.getElementById('entity-list');
    if(!container){
        container = document.createElement('div');
        container.id = 'entity-list';
        container.style.margin = "10px 0";
        document.getElementById('prop-player').parentNode.appendChild(container);
    }
    container.innerHTML = "";

    propEntities.forEach((e, index)=>{
        let div = document.createElement("div");
        div.id = "player-list";
        div.textContent = e + " ";
        div.style.margin = "4px";

        // Remove player button
        let btn = document.createElement("button");
        btn.textContent = "Remove";
        btn.style.marginLeft = "10px";
        btn.style.padding = "3px 8px";
        btn.style.backgroundColor = "#ff4d4d";
        btn.style.color = "#fff";
        btn.style.border = "none";
        btn.style.borderRadius = "4px";
        btn.style.cursor = "pointer";

        btn.onclick = ()=>{
    if(confirm(`Remove player "${e}" from betting?`)){
        propEntities.splice(index,1);
        delete propsTemplate[e]; // remove their props
        localStorage.setItem('propEntities', JSON.stringify(propEntities));
        localStorage.setItem('propsTemplate', JSON.stringify(propsTemplate));
        populatePropAdmin(); // refresh dropdown + entity list
        populatePlayers();   // update betting dropdown
    }
};

        div.appendChild(btn);
        container.appendChild(div);
    });
}

function renderPropsList(){
    const container = document.getElementById('props-list');
    container.innerHTML = "";
    const player = document.getElementById('prop-player').value;
    if(!propsTemplate[player]) propsTemplate[player]=[];

    propsTemplate[player].forEach((p, i)=>{
        const div = document.createElement('div');
        div.textContent = `${p.name} (${p.odds}x) `;
        div.style.margin = "4px";

        const btn = document.createElement('button');
        btn.textContent = "Remove";
        btn.style.marginLeft="10px";
        btn.onclick = ()=>{
            if(confirm(`Remove prop "${p.name}" from ${player}?`)){
                propsTemplate[player].splice(i,1);
                localStorage.setItem('propsTemplate', JSON.stringify(propsTemplate));
                renderPropsList();
                populatePlayers(); // update betting dropdown
            }
        };
        div.appendChild(btn);
        container.appendChild(div);
    });
}

// Add new prop
document.getElementById('add-prop').addEventListener('click',()=>{
    if(!currentUser || !users[currentUser].isAdmin) return;
    let player = document.getElementById('prop-player').value;
    let name = document.getElementById('new-prop').value.trim();
    let odds = parseInt(document.getElementById('new-odds').value);

    if(name && odds > 0){
        if(!propsTemplate[player]) propsTemplate[player] = [];
        propsTemplate[player].push({name, odds});
        localStorage.setItem('propsTemplate', JSON.stringify(propsTemplate));
        document.getElementById('new-prop').value = "";
        document.getElementById('new-odds').value = "";
        renderPropsList();
        populatePlayers(); // update betting dropdown
    }
});

// ------------------ DELETE USER ------------------
function deleteUser(username){
    if(!currentUser || !users[currentUser].isAdmin) return;
    if(confirm(`Admin, confirm delete ${username}?`)){ delete users[username]; updateLeaderboards(); updateUI(); alert(`${username} deleted`); }
}

// ------------------ CLEAR VOTES ------------------
document.getElementById('clear-votes').addEventListener('click',()=>{
    if(!currentUser || !users[currentUser].isAdmin) return;
    Object.keys(users).forEach(u=>users[u].votesThisMatch={});
    mvpScores={}; mvpHistory=[]; currentMatch=0;
    localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
    localStorage.removeItem('mvpScores'); localStorage.removeItem('mvpHistory'); localStorage.setItem('currentMatch', currentMatch);
    updateLeaderboards(); updateUI(); alert("Votes cleared.");
});
// TEMP: Promote the current user to admin. Remove after use.
document.getElementById('promote-me').addEventListener('click', async ()=>{
  const u = auth.currentUser;
  if(!u){ alert("Not signed in."); return; }

  // Safety: only allow if the username is exactly 'admin'
  const uname = (u.displayName && u.displayName.trim()) ? u.displayName.trim() : (u.email ? u.email.split("@")[0] : "");
  if (uname !== 'admin') {
    alert("For safety, only the 'admin' user can self-promote here.");
    return;
  }

  try {
    await db.collection('users').doc(u.uid).set({ roles: { admin: true } }, { merge: true });
    // Keep your local flag in sync so the Admin tab shows
    if (!users[uname]) users[uname] = {};
    users[uname].isAdmin = true;
    localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
    updateUI();

    alert("You're now an admin. (Remove this button after confirming.)");
  } catch (e) {
    alert("Failed to promote: " + e.message);
  }
});
</script>
</body>
</html>
