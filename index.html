<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kickcoins - Fantasy Betting</title>
<style>
/* --- STYLES SAME AS ORIGINAL --- */
body { font-family: Arial, sans-serif; background-color: #121212; color: #fff; margin:0; padding:0; }
header { display:flex; justify-content:space-between; align-items:center; padding:10px 20px; background-color:#1a1a1a; }
header .account { display:flex; align-items:center; gap:15px; }
.tabs { display:flex; background-color:#1a1a1a; }
.tab { flex:1; padding:10px; text-align:center; cursor:pointer; border-bottom:2px solid #121212; }
.tab.active { border-bottom:2px solid #00ff00; }
main { padding:20px; }
.card { background-color:#1f1f1f; padding:15px; margin:10px 0; border-radius:8px; }
.prop { display:flex; justify-content:space-between; align-items:center; margin:10px 0; }
.prop input[type="number"] { width:70px; margin-left:10px; }
select { padding:5px; }
button { padding:5px 10px; cursor:pointer; border:none; border-radius:5px; }
button:disabled { background-color: #555; cursor: not-allowed; }
.green { color:#00ff00; }
.red { color:#ff0000; }
table { width:100%; border-collapse:collapse; }
th, td { padding:8px; text-align:left; border-bottom:1px solid #333; }
#login-card { max-width:400px; margin:50px auto; }
.bet-payout { margin-left:10px; font-weight:bold; }
.match-card {
    background-color: #1f1f1f; /* Slightly different from page */
    padding: 10px 15px;
    margin-bottom: 15px;
    border-radius: 8px;
    border: 1px solid #333; /* subtle outline */
    box-shadow: 0 2px 4px rgba(0,0,0,0.3); /* optional subtle shadow */
}
.match-card strong {
    display: block;
    margin-bottom: 8px;
    font-size: 1.1em;
}
.match-card ul {
    padding-left: 20px;
    margin: 0;
}
.match-card div.total {
    margin-top: 8px;
}
.mvp-card {
    background-color: #1f1f1f;
    padding: 10px 15px;
    margin-bottom: 15px;
    border-radius: 8px;
    border: 1px solid #333;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
.mvp-card strong {
    display: block;
    margin-bottom: 8px;
    font-size: 1.1em;
}
.mvp-card div.result {
    padding-left: 20px;
    margin: 2px 0;
}
/* Admin resolve bets styling */
.resolve-bet {
    background-color: #1f1f1f;
    padding: 10px;
    margin: 10px 0;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.resolve-bet-info {
    font-weight: bold;
    color: #fff;
    margin-bottom: 5px;
}

.resolve-buttons {
    display: flex;
    gap: 15px;
}

.resolve-buttons button {
    padding: 8px 20px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    font-weight: bold;
}

.resolve-buttons button.win {
    background-color: #00ff00;
    color: #000;
}

.resolve-buttons button.lose {
    background-color: #ff0000;
    color: #fff;
}
.admin-bet-card { margin: 10px 0; padding: 10px; background-color:#1f1f1f; border-radius:8px; }
.admin-win-btn { background-color: #00ff00; color: #000; margin-right: 10px; padding:5px 12px; font-weight:bold; cursor:pointer; border:none; border-radius:5px; }
.admin-lose-btn { background-color: #ff0000; color: #000; padding:5px 12px; font-weight:bold; cursor:pointer; border:none; border-radius:5px; }
.total-coins {
    font-weight: bold;
    background-color: #222;   /* Slightly different from card */
    padding: 5px 10px;
    border-radius: 5px;
    margin-top: 8px;
}
/* Admin section cleanup */
.admin-section {
  background: #1e1e1e;
  border-radius: 8px;
  padding: 15px;
  margin-bottom: 20px;
}

.admin-section h3 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 18px;
  color: #fff;
}

.tag-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.tag {
  background: #2c2c2c;
  padding: 5px 10px;
  border-radius: 20px;
  color: #fff;
  font-size: 14px;
  display: flex;
  align-items: center;
}

.tag button {
  margin-left: 8px;
  background: #ff4d4d;
  border: none;
  border-radius: 50%;
  width: 18px;
  height: 18px;
  font-size: 12px;
  cursor: pointer;
  color: white;
}
</style>
<!-- Firebase (compat build for Auth) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
</head>
<body>

<header>
<h1>Kickcoins ⚽</h1>
<div class="account" id="account-info"></div>
<button id="logout-btn" style="display:none;">Logout</button>
</header>

<div id="login-card" class="card">
<h2>Login / Create Account</h2>
<label>Username:</label><input type="text" id="login-username"><br><br>
<label>Password:</label><input type="password" id="login-password"><br><br>
<button id="login-btn">Login</button>
<button id="create-btn">Create Account</button>
</div>

<div id="app" style="display:none;">
<div class="tabs">
    <div class="tab active" data-tab="vote">MVP Voting</div>
    <div class="tab" data-tab="bet">Betting</div>
    <div class="tab" data-tab="leaderboard">Leaderboards</div>
    <div class="tab" data-tab="history">Bet History</div>
    <div class="tab" data-tab="admin">Admin</div>
</div>

<main>
<!-- MVP Voting -->
<div class="tab-content" id="vote-tab">
    <div class="card">
        <h2>Vote for MVP</h2>
        <label>1st Place:</label>
        <select id="vote1"></select>
        <label>2nd Place:</label>
        <select id="vote2"></select>
        <label>3rd Place:</label>
        <select id="vote3"></select>
        <button id="submit-votes">Submit Votes</button>
    </div>
</div>

<!-- Betting -->
<div class="tab-content" id="bet-tab" style="display:none;">
    <div class="card">
        <h2>Betting</h2>
        <div id="balance-display"></div>
        <label>Select Player:</label>
        <select id="player-select"></select>
        <div id="props-container"></div>
        <div>Total Potential Payout: <span id="total-payout" class="bet-payout">0</span></div>
        <button id="submit-bets">Place Bets</button>
    </div>
</div>

<!-- Leaderboards -->
<div class="tab-content" id="leaderboard-tab" style="display:none;">
    <div class="card">
        <h2>Overall MVP Leaderboard</h2>
        <table id="mvp-leaderboard">
            <thead><tr><th>Place</th><th>Player</th><th>Points</th></tr></thead>
            <tbody></tbody>
        </table>
    </div>
    <div class="card">
        <h2>MVP History per Match</h2>
        <div id="mvp-history"></div>
    </div>
</div>

<!-- Bet History -->
<div class="tab-content" id="history-tab" style="display:none;">
    <div class="card">
        <h2>Betting Leaderboard</h2>
        <table id="coin-leaderboard">
            <thead><tr><th>Place</th><th>Player</th><th>Coins</th><th>Admin</th></tr></thead>
            <tbody></tbody>
        </table>
    </div>
    <div class="card" id="history-container"></div>
</div>

<!-- Admin -->
<div class="tab-content" id="admin-tab" style="display:none;">
    <div class="card">
        <h2>Admin Controls</h2>
        <button id="open-bets">Open Betting</button>
        <button id="close-bets" disabled>Close Betting</button>
        <button id="start-match" disabled>Start Match</button>
        <button id="end-match" disabled>End Match</button>
        <div id="resolve-bets"></div>
    </div>
    <div class="card">
<h2>Manage Betting Props</h2>

<!-- Admin props area: left = players/entity controls, right = add prop + current props -->
<div class="admin-section" style="display:flex; gap:20px; flex-wrap:wrap; align-items:flex-start;">

  <!-- Left column: player select + entity (player) management (JS will create entity controls if missing) -->
  <div style="min-width:260px; width:260px;">
    <label style="display:block; margin-bottom:6px;">Player:</label>
    <select id="prop-player" style="width:100%; padding:6px; margin-bottom:8px;"></select>

    <!-- NOTE: Do NOT remove this area — renderEntityList() may create or update #entity-list -->
    <div id="players-list-wrapper" style="margin-top:8px;">
      <small style="opacity:0.8;">Players (use remove buttons):</small>
      <div id="entity-list" style="margin-top:8px;"></div>
    </div>
  </div>

  <!-- Right column: add prop & props list -->
  <div style="flex:1; min-width:300px;">
    <label style="display:block; margin-bottom:6px;">Add Prop</label>
    <input type="text" id="new-prop" placeholder="Enter prop name" style="padding:6px; width:60%;" />
    <input type="number" id="new-odds" placeholder="Odds (x)" min="1" style="padding:6px; width:30%; margin-left:6px;" />
    <button id="add-prop" type="button" style="display:block; margin-top:8px; padding:6px 8px;">Add Prop</button>

    <div style="margin-top:12px;">
      <h4 style="margin:6px 0;">Current Props</h4>
      <div id="props-list"></div>
    </div>
  </div>
</div>
</div>

<div class="admin-section">
  <h3>Current Players</h3>
  <div id="players-container" class="tag-list"></div>
</div>
    </div>
    <div class="card">
  <h2>Admin Tests</h2>
  <button id="clear-votes">Clear Mvp Votes</button>
  <button id="normalize-roles" style="margin-left:10px;">Normalize Roles (set non-admins to false)</button>
  <button id="promote-me" style="margin-left:10px;">Make Me Admin (temp)</button>
  <button id="seed-config" style="margin-left:10px;">Seed Config Docs</button>
  <button id="reset-state" style="margin-left:10px;">Reset App State</button>
  <button id="debug-status" style="margin-left:10px;">Debug Status</button>
</div>
</div>
</main>

<script>
// ------------------ STORAGE ------------------
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyAjq_4nylYza2VDiiT6KJq9VZ7auMe7gxo",
  authDomain: "kickcoins-v3.firebaseapp.com",
  projectId: "kickcoins-v3",
  storageBucket: "kickcoins-v3.appspot.com", // <-- FIXED
  messagingSenderId: "601991069210",
  appId: "1:601991069210:web:422a5389bcc9dd62845ba3",
  measurementId: "G-16L5MNM4E5"
};

// Initialize Firebase (exactly once)
firebase.initializeApp(firebaseConfig);
// Initialize services AFTER app init
const auth = firebase.auth();
const db   = firebase.firestore();
    // --- DIAG STEP 1A: check project details ---
setTimeout(()=>{
  const opts = firebase.app().options || {};
  alert(
    'Project: ' + (opts.projectId || '(none)') +
    '\nAuth domain: ' + (opts.authDomain || '(none)')
  );
}, 0);
    window.addEventListener('error', (e) => {
  alert('JS Error: ' + (e && e.message ? e.message : String(e)));
});
var users = {};

// === FIRESTORE ROSTERS ===
// Betting roster (was your old "players" doc)
let propEntities = [];
let propsTemplate = {};
let playersUnsub = null;
let propsUnsubs = {};

// MVP roster (separate doc so MVP voting list is independent)
let mvpEntities = [];
let mvpPlayersUnsub = null;
        function attachMvpPlayersListener() {
  if (mvpPlayersUnsub) { try { mvpPlayersUnsub(); } catch(_){} mvpPlayersUnsub = null; }

  // MVP roster lives at: /config/mvpPlayers { list: [...] }
  mvpPlayersUnsub = db.collection('config').doc('mvpPlayers').onSnapshot(
    (doc) => {
      const d = doc.data() || {};
      mvpEntities = Array.isArray(d.list) ? d.list : [];
      populateVoting(); // refresh MVP dropdowns
    },
    (err) => alert('MVP players listener error: ' + (err && err.message ? err.message : err))
  );
}
function attachPlayersListener() {
  if (playersUnsub) { playersUnsub(); playersUnsub = null; }

  playersUnsub = db.collection('config').doc('players').onSnapshot(
    (doc) => {
      const d = doc.data() || {};
      const newList = Array.isArray(d.list) ? d.list : [];

      // detach listeners for players that were removed
      Object.keys(propsUnsubs).forEach(p => {
        if (!newList.includes(p)) {
          try { propsUnsubs[p] && propsUnsubs[p](); } catch(_) {}
          delete propsUnsubs[p];
          delete propsTemplate[p];
        }
      });

      // attach listeners for any new players
      newList.forEach(p => { if (!propsUnsubs[p]) attachPropsListener(p); });

      propEntities = newList;

      // refresh UIs
      populatePlayers();   // betting dropdown
      populateVoting();    // MVP dropdowns
      populatePropAdmin(); // admin UI
    },
    (err) => alert('Players listener error: ' + (err && err.message ? err.message : err))
  );
}

function attachPropsListener(player) {
  if (propsUnsubs[player]) { try { propsUnsubs[player](); } catch(_) {} propsUnsubs[player] = null; }

  const ref = db.collection('config')
                .doc('propsTemplate')
                .collection('byPlayer')
                .doc(player);

  propsUnsubs[player] = ref.onSnapshot(
    (doc) => {
      const d = doc.data() || {};
      propsTemplate[player] = Array.isArray(d.items) ? d.items : [];

      // refresh if this player is currently in view
      if (document.getElementById('player-select')?.value === player) {
        populateProps();
      }
      if (document.getElementById('prop-player')?.value === player) {
        renderPropsList();
      }
    },
    (err) => alert('Props listener error (' + player + '): ' + (err && err.message ? err.message : err))
  );
}
let currentMatch = 0; // ✅ keep a local var; Firestore listener keeps it in sync
let adminBetsUnsub = null; // live listener for unresolved bets (Firestore)
// === MVP (Firestore-driven) ===
let myVoteUnsub = null;
function detachMyVote() {
  if (myVoteUnsub) {
    myVoteUnsub();
    myVoteUnsub = null;
  }
}
let currentUser=null;
// === Firestore-backed "me" cache (single source of truth for balances/admin) ===
let __me = { coins: 0, availableCoins: 0, roles: { admin: false }, username: "" };
let __meUnsub = null;

function isSignedIn(){ return !!auth.currentUser; }
function isAdmin(){
  const a = __me && __me.roles ? __me.roles.admin : false;
  // tolerate boolean true, string "true", or number 1
  return a === true || a === 'true' || a === 1;
}
let myBetsUnsub = null; // live listener for "My Bets" (Firestore)

// ------------------ LOGIN ------------------
// ------------------ FIREBASE LOGIN / CREATE / LOGOUT ------------------
function renderBalanceFromFS(){
  const el = document.getElementById('balance-display');
  if (!el) return;
  el.textContent = `Total: ${__me.coins} 💰 | Available: ${__me.availableCoins} 💸`;
}
// Toggle login vs app UI
function showLogin(show=true){
    document.getElementById('login-card').style.display = show ? 'block' : 'none';
    document.getElementById('app').style.display = !show ? 'block' : 'none';
    document.getElementById('logout-btn').style.display = !show ? 'inline' : 'none';
}

// Helper: convert username to fake email
function usernameToEmail(username){
    return username + "@kickcoins.com";
}

// LOGIN
document.getElementById('login-btn').addEventListener('click', async ()=>{
    const username = document.getElementById('login-username').value.trim();
    const pass = document.getElementById('login-password').value;
    if(!username || !pass){ alert("Enter username and password."); return; }
    try {
        const email = usernameToEmail(username);
        await auth.signInWithEmailAndPassword(email, pass);
        currentUser = username;
        if(!users[username]){
            users[username] = { password:pass, totalCoins:100, availableCoins:0, votesThisMatch:{}, bets:[], mvpPoints:0, history:[], voted:false };
            localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
        }
        showLogin(false);
        updateUI(); populateVoting(); populatePlayers(); updateLeaderboards(); populatePropAdmin();
        alert("Logged in!");
    } catch(err){ alert("Login failed: " + err.message); }
});

// CREATE
// CREATE (allows create even if local user exists)
document.getElementById('create-btn').addEventListener('click', async ()=>{
  const username = document.getElementById('login-username').value.trim();
  const pass = document.getElementById('login-password').value;
  if(!username || !pass){ alert("Enter username and password."); return; }

  const email = usernameToEmail(username);

  try {
    // Try to create in Firebase Auth
    const cred = await auth.createUserWithEmailAndPassword(email, pass);
    await cred.user.updateProfile({ displayName: username });

    // Ensure local mirror exists (keeps rest of UI happy for now)
    if(!users[username]){
      users[username] = { password:pass, totalCoins:100, availableCoins:0, votesThisMatch:{}, bets:[], mvpPoints:0, history:[], voted:false };
      localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
    }

    currentUser = username;
    showLogin(false);
    updateUI(); populateVoting(); populatePlayers(); updateLeaderboards(); populatePropAdmin();
    alert("Account created & logged in!");
  } catch(err){
    if (err && err.code === 'auth/email-already-in-use') {
      // If account exists in Firebase, just sign in instead
      try {
        await auth.signInWithEmailAndPassword(email, pass);
        currentUser = username;
        if(!users[username]){
          users[username] = { password:pass, totalCoins:100, availableCoins:0, votesThisMatch:{}, bets:[], mvpPoints:0, history:[], voted:false };
          localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
        }
        showLogin(false);
        updateUI(); populateVoting(); populatePlayers(); updateLeaderboards(); populatePropAdmin();
        alert("Logged in!");
      } catch(signInErr){
        alert("Signup/Login failed: " + signInErr.message);
      }
    } else {
      alert("Signup failed: " + err.message);
    }
  }
});

// LOGOUT
document.getElementById('logout-btn').addEventListener('click', async ()=>{
  try {
    await auth.signOut();
  } catch (err) {
    alert("Logout failed: " + (err?.message || err));
    } finally {
    currentUser = null;
    showLogin(true);

    // Detach ALL listeners so anon user doesn’t trip "permission denied"
    try { if (myBetsUnsub)       { myBetsUnsub();       myBetsUnsub = null; } } catch(_){}
    try { if (myVoteUnsub)       { myVoteUnsub();       myVoteUnsub = null; } } catch(_){}
    try { if (adminBetsUnsub)    { adminBetsUnsub();    adminBetsUnsub = null; } } catch(_){}
    try { if (playersUnsub)      { playersUnsub();      playersUnsub = null; } } catch(_){}
    try { if (mvpPlayersUnsub)   { mvpPlayersUnsub();   mvpPlayersUnsub = null; } } catch(_){}
    try {
      Object.keys(propsUnsubs || {}).forEach(k=>{
        try { propsUnsubs[k] && propsUnsubs[k](); } catch(_){}
        delete propsUnsubs[k];
      });
    } catch(_) {}
    }
});
 // React to Firebase login state changes (SAFE VERSION)
auth.onAuthStateChanged(async (user) => {
  // Clean up previous listener
  if (__meUnsub) { try { __meUnsub(); } catch(_){} __meUnsub = null; }

  if (!user) {
    currentUser = null;
    __me = { coins: 0, availableCoins: 0, roles: { admin:false }, username: "" };
    showLogin(true);
    updateUI();
    return;
  }

  // derive username from profile or email
  const username = (user.displayName && user.displayName.trim())
    ? user.displayName.trim()
    : (user.email ? user.email.split("@")[0] : "user");
  currentUser = username;

  // ensure user doc exists
  const userRef = db.collection('users').doc(user.uid);
  let snap = await userRef.get();
  if (!snap.exists) {
    await userRef.set({
      email: user.email || null,
      username,
      coins: 100,
      availableCoins: 0,
      roles: { admin: false },
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
    snap = await userRef.get();
  }

  // live listener to my balances + roles
  __meUnsub = userRef.onSnapshot((doc) => {
    const d = doc.exists ? (doc.data() || {}) : {};
    __me = {
      coins: typeof d.coins === 'number' ? d.coins : 100,
      availableCoins: typeof d.availableCoins === 'number' ? d.availableCoins : 0,
      roles: d.roles || { admin: false },
      username: d.username || username
    };
    updateUI();           // header + admin tab vis
    renderBalanceFromFS(); // betting tab header
  });

  // proceed
 showLogin(false);
populateVoting();
populatePlayers();
updateLeaderboards();
populatePropAdmin();
attachPlayersListener();     // betting roster
attachMvpPlayersListener();  // MVP roster (new)
});
// ---------- FIRESTORE APP STATE ----------
const stateRef = db.collection('app').doc('state');

// Ensure the state doc exists once (safe to call always)
async function ensureState() {
  const snap = await stateRef.get();
  if (!snap.exists) {
    await stateRef.set({ bettingOpen: false, matchActive: false, currentMatch: 0 });
  }
}
ensureState();
// Ensure the config docs exist so listeners have something to read
async function ensureConfigDocs() {
  const cfg = db.collection('config');

  const playersDoc = await cfg.doc('players').get();
  if (!playersDoc.exists) {
    await cfg.doc('players').set({ list: [] }); // betting roster
  }

  const mvpPlayersDoc = await cfg.doc('mvpPlayers').get();
  if (!mvpPlayersDoc.exists) {
    await cfg.doc('mvpPlayers').set({ list: [] }); // MVP roster (separate)
  }

  const propsRoot = await cfg.doc('propsTemplate').get();
  if (!propsRoot.exists) {
    await cfg.doc('propsTemplate').set({}); // container for byPlayer
  }
}
ensureConfigDocs();

// Real-time listener to reflect buttons & keep local mirror in sync
stateRef.onSnapshot((snap) => {
  if (!snap.exists) return;
  const st = snap.data();
  window.__appState = st;

  // keep your local currentMatch in sync for the parts still using it
  if (typeof currentMatch !== 'undefined') currentMatch = Number(st.currentMatch || 0);

  // Admin button enable/disable (guard if elements exist)
  const ob = document.getElementById('open-bets');
  const cb = document.getElementById('close-bets');
  const sm = document.getElementById('start-match');
  const em = document.getElementById('end-match');

  const userIsAdmin = isAdmin();

  if (ob) ob.disabled = !userIsAdmin || !!st.bettingOpen;
  if (cb) cb.disabled = !userIsAdmin || !st.bettingOpen;
  if (sm) sm.disabled = !userIsAdmin || !!st.matchActive || !!st.bettingOpen;
  if (em) em.disabled = !userIsAdmin || !st.matchActive;

  // 🔴 NEW LINE: attach/update the live "My Bets" listener for this match
  maybeAttachMyBetsListener(Number(st.currentMatch || 0));
});
function maybeAttachMyBetsListener(matchNum){
  // Only if signed in and match number looks valid
  const u = auth.currentUser;
  if (!u || !Number.isFinite(matchNum) || matchNum <= 0) {
    if (myBetsUnsub) { myBetsUnsub(); myBetsUnsub = null; }
    renderMyBets([]); // clear the section
    return;
  }

  // Re-subscribe if match changed
  if (myBetsUnsub) { myBetsUnsub(); myBetsUnsub = null; }

  const q = db.collection('matches')
              .doc(String(matchNum))
              .collection('bets')
              .where('uid','==', u.uid);

  myBetsUnsub = q.onSnapshot((qsnap)=>{
    const bets = [];
    qsnap.forEach(doc => bets.push({ id: doc.id, ...doc.data() }));
    renderMyBets(bets);
  }, (err)=>{
    alert('Live bets listener error: ' + (err && err.message ? err.message : String(err)));
  });
}

function renderMyBets(bets){
  const container = document.getElementById('history-container');
  if (!container) return;

  // Remove existing FS section if present (so we can re-render)
  const old = document.getElementById('fs-my-bets');
  if (old) old.remove();

  const wrap = document.createElement('div');
  wrap.id = 'fs-my-bets';
  wrap.className = 'match-card';

  const title = document.createElement('strong');
  title.textContent = 'My Live Bets (Firestore)';
  wrap.appendChild(title);

  if (!bets.length) {
    const p = document.createElement('div');
    p.textContent = 'No bets yet for this match.';
    wrap.appendChild(p);
  } else {
    const ul = document.createElement('ul');
    let totalStake = 0, totalWon = 0;

    bets.forEach(b => {
      const li = document.createElement('li');
      li.textContent = `${b.player} - ${b.prop} (${b.odds}x) | Amount: ${b.amount} | ${b.resolved ? (b.won ? 'Won' : 'Lost') : 'Pending'}`;
      if (!b.resolved) li.style.color = 'yellow';
      else li.style.color = b.won ? 'green' : 'red';
      ul.appendChild(li);

      totalStake += Number(b.amount || 0);
      if (b.resolved && b.won) {
        totalWon += (Number(b.amount||0) * Number(b.odds||0)) + Number(b.amount||0);
      }
    });

    wrap.appendChild(ul);

    const totals = document.createElement('div');
    totals.className = 'total total-coins';
    totals.textContent = `Total Coins Bet: ${totalStake} | Total Coins Won: ${totalWon}`;
    if (totalWon < 10) totals.style.color = 'red';
    else if (totalWon === 10) totals.style.color = 'yellow';
    else totals.style.color = 'green';

    wrap.appendChild(totals);
  }

  // Prepend so it appears above your old local history (which we’ll retire later)
  container.prepend(wrap);
}
// ========== FULL BET HISTORY (FIRESTORE) – RENDERER ==========
function renderFullHistoryFS(bets) {
  const container = document.getElementById('history-container');
  if (!container) return;

  // Remove old FS section if present
  const old = document.getElementById('fs-full-history');
  if (old) old.remove();

  const wrap = document.createElement('div');
  wrap.id = 'fs-full-history';
  wrap.className = 'match-card';

  const title = document.createElement('strong');
  title.textContent = 'Full Bet History (Firestore)';
  wrap.appendChild(title);

  // Error state shortcut
  if (bets && bets.__error) {
    const p = document.createElement('div');
    p.style.color = 'red';
    p.textContent = 'Error: ' + bets.__error;
    wrap.appendChild(p);
    container.appendChild(wrap);
    return;
  }

  if (!bets || bets.length === 0) {
    const p = document.createElement('div');
    p.textContent = 'No bets yet.';
    wrap.appendChild(p);
    container.appendChild(wrap);
    return;
  }

  // Group by match number
  const byMatch = {};
  bets.forEach(b => {
    const m = Number(b.match || 0) || 0;
    if (!byMatch[m]) byMatch[m] = [];
    byMatch[m].push(b);
  });

  // Sort matches newest->oldest
  const matchNums = Object.keys(byMatch).map(n => Number(n)).sort((a,b)=>b-a);

  matchNums.forEach(matchNum => {
    const section = document.createElement('div');
    section.className = 'match-card';
    const header = document.createElement('strong');
    header.textContent = `Match ${matchNum}`;
    section.appendChild(header);

    const ul = document.createElement('ul');
    let totalStake = 0, totalWon = 0;

    // Sort each match’s bets newest->oldest
    const rows = byMatch[matchNum].slice().sort((a,b)=>{
      const ta = a.createdAt && a.createdAt.toMillis ? a.createdAt.toMillis() : 0;
      const tb = b.createdAt && b.createdAt.toMillis ? b.createdAt.toMillis() : 0;
      return tb - ta;
    });

    rows.forEach(b => {
      const li = document.createElement('li');
      li.textContent = `${b.player} - ${b.prop} (${b.odds}x) | Amount: ${b.amount} | ${b.resolved ? (b.won ? 'Won' : 'Lost') : 'Pending'}`;
      if (!b.resolved) li.style.color = 'yellow';
      else li.style.color = b.won ? 'green' : 'red';
      ul.appendChild(li);

      totalStake += Number(b.amount || 0);
      if (b.resolved && b.won) {
        totalWon += (Number(b.amount||0) * Number(b.odds||0)) + Number(b.amount||0);
      }
    });

    section.appendChild(ul);

    const totals = document.createElement('div');
    totals.className = 'total total-coins';
    totals.textContent = `Total Coins Bet: ${totalStake} | Total Coins Won: ${totalWon}`;
    if (totalWon < 10) totals.style.color = 'red';
    else if (totalWon === 10) totals.style.color = 'yellow';
    else totals.style.color = 'green';
    section.appendChild(totals);

    wrap.appendChild(section);
  });

  // Put full history BELOW the live “My Bets” box
  container.appendChild(wrap);
}

// ========== FULL BET HISTORY (FIRESTORE) – LOADER ==========
async function loadFullBetHistoryFS() {
  try {
    const u = auth.currentUser;
    if (!u) {
      renderFullHistoryFS([]); // signed-out -> empty
      return;
    }

    // Query all "bets" subcollections, only my uid; sort on client
    const q = db.collectionGroup('bets').where('uid','==', u.uid);
    const qsnap = await q.get();

    const rows = [];
    qsnap.forEach(doc => rows.push({ id: doc.id, ...doc.data() }));

    // Sort: newest match first, then newest createdAt first
    rows.sort((a,b) => {
      const ma = Number(a.match || 0), mb = Number(b.match || 0);
      if (mb !== ma) return mb - ma;
      const ta = a.createdAt && a.createdAt.toMillis ? a.createdAt.toMillis() : 0;
      const tb = b.createdAt && b.createdAt.toMillis ? b.createdAt.toMillis() : 0;
      return tb - ta;
    });

    renderFullHistoryFS(rows);
  } catch (err) {
    renderFullHistoryFS({ __error: (err && err.message ? err.message : String(err)) });
  }
}
async function renderCoinLeaderboardFS(){
  const tbody = document.querySelector('#coin-leaderboard tbody');
  if (!tbody) return;
  tbody.innerHTML = '';

  try {
    const snap = await db.collection('users')
      .where('roles.admin', '==', false)
      .orderBy('coins', 'desc')
      .get();

    let rank = 1;
    snap.forEach(doc => {
      const d = doc.data() || {};
      const name = d.username || '(user)';
      const coins = typeof d.coins === 'number' ? d.coins : 0;

      const icon = rank===1?'🥇':rank===2?'🥈':rank===3?'🥉':rank<7?'🪨':'🍆';
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${rank} ${icon}</td><td>${name}</td><td>${coins}</td><td></td>`;
      tbody.appendChild(tr);
      rank++;
    });
  } catch (e) {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td colspan="4" style="color:red;">Leaderboard load failed: ${e && e.message ? e.message : e}</td>`;
    tbody.appendChild(tr);
  }
}
// ------------------ TAB NAV ------------------
document.querySelectorAll('.tab').forEach(tab=>{
  tab.addEventListener('click',()=>{
    // switch active tab
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    tab.classList.add('active');
    // switch visible content
    document.querySelectorAll('.tab-content').forEach(tc=>tc.style.display='none');
    document.getElementById(tab.dataset.tab+'-tab').style.display='block';

    updateUI();

    if (tab.dataset.tab === "history") {
      // keep your old local history for now (we’ll remove later)
      // 🔴 NEW: Firestore leaderboard + full history
      renderCoinLeaderboardFS(); 
      loadFullBetHistoryFS();     // <<-- this replaces your old renderFullHistoryFS()
    }

    if (tab.dataset.tab === "admin" && currentUser && isAdmin()) {
      renderPropsList();
      reviewBetsForAdminFS();
    }
    // inside tab click handler:
if (tab.dataset.tab === "vote") {
  populateVoting(); // ensures listener attaches / UI fills
}
  });
});

// ------------------ ACCOUNT DISPLAY ------------------
function updateUI(){
  // account header
  const accEl = document.getElementById('account-info');
  if (accEl) {
    const name = currentUser || '(signed out)';
    accEl.innerHTML = `${name} | Total: ${__me.coins} 💰 | Available: ${__me.availableCoins} 💸`;
  }

  // Admin tab visibility based on Firestore role (not local mirror)
  const adminTab = document.querySelector('.tab[data-tab="admin"]');
  const adminContent = document.getElementById('admin-tab');
  if (adminTab && adminContent) {
    if (isAdmin()) {
      adminTab.style.display = "block";
    } else {
      adminTab.style.display = "none";
      adminContent.style.display = "none";
      const active = document.querySelector(".tab.active");
      if (active && active.dataset.tab === "admin") {
        document.querySelector('.tab[data-tab="vote"]').click();
      }
    }
  }
}

// ------------------ MVP VOTING (Firestore) ------------------
function populateVoting(){
  // Use the MVP roster only
  ["vote1","vote2","vote3"].forEach(id=>{
    const sel = document.getElementById(id);
    sel.innerHTML = "";
    (mvpEntities || []).forEach(p=>{
      const opt = document.createElement("option");
      opt.value = p;
      opt.text = p;
      sel.appendChild(opt);
    });
  });

  // Attach / reattach the listener that will also prefill votes if they exist
  attachMyVoteListener();
}
function attachMyVoteListener(){
  detachMyVote();
  const st = window.__appState || {};
  const matchNum = Number(st.currentMatch || 0);
  const u = auth.currentUser;
  if (!u || !matchNum) return;

  const voteRef = db.collection('matches').doc(String(matchNum)).collection('votes').doc(u.uid);
  myVoteUnsub = voteRef.onSnapshot((doc)=>{
    const btn = document.getElementById('submit-votes');
    if (!btn) return;

    if (!doc.exists) {
      btn.disabled = false;
      btn.textContent = 'Submit Votes';
      return;
    }

    // pre-fill UI (optional)
const v = doc.data() || {};
if (v.first  && mvpEntities.includes(v.first))  document.getElementById('vote1').value = v.first;
if (v.second && mvpEntities.includes(v.second)) document.getElementById('vote2').value = v.second;
if (v.third  && mvpEntities.includes(v.third))  document.getElementById('vote3').value = v.third;
    // Allow overwriting until match ends (simple UX)
    btn.disabled = false;
    btn.textContent = 'Update Votes';
  }, (err)=>{
    alert('Vote listener error: ' + (err && err.message ? err.message : String(err)));
  });
}

document.getElementById('submit-votes').addEventListener('click', async ()=>{
  try {
    const st = window.__appState || {};
    if (!st.matchActive) { alert("Match not started yet."); return; }

    const u = auth.currentUser;
    if (!u) { alert("Not signed in."); return; }

    const first  = document.getElementById('vote1').value;
    const second = document.getElementById('vote2').value;
    const third  = document.getElementById('vote3').value;

    if (new Set([first,second,third]).size < 3) {
      alert("Cannot vote the same player multiple times.");
      return;
    }

    const matchNum = Number(st.currentMatch || 0);
    if (!matchNum) { alert('No active match id.'); return; }

    await db.collection('matches').doc(String(matchNum)).collection('votes').doc(u.uid).set({
      uid: u.uid,
      username: currentUser || '',
      first, second, third,
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge: true });

    alert('Votes saved!');
  } catch (e) {
    alert('Submit votes failed: ' + (e && e.message ? e.message : e));
  }
});

// ------------------ BETTING ------------------
function populatePlayers(){
    let sel=document.getElementById('player-select'); sel.innerHTML="";
    propEntities.forEach(p=>{
        let opt=document.createElement("option"); opt.value=p; opt.text=p; sel.appendChild(opt);
    });
    sel.addEventListener('change', populateProps);
}
function populateProps(){
  const container = document.getElementById('props-container');
  container.innerHTML = "";
  const player = document.getElementById('player-select').value;
  const avail = Number(__me.availableCoins || 0);

  (propsTemplate[player] || []).forEach(prop=>{
    const card = document.createElement("div");
    card.className = "prop";

    const label = document.createElement("span");
    label.textContent = `${prop.name} (${prop.odds}x)`;
    label.className = "green";

    const input = document.createElement("input");
    input.type = "number";
    input.min = 0;
    input.max = avail;                      // 🔴 from Firestore now
    input.dataset.odds = prop.odds;
    input.oninput = updatePotentialPayout;

    card.appendChild(label);
    card.appendChild(input);
    container.appendChild(card);
  });

  updatePotentialPayout();
}
function updatePotentialPayout(){
    const container=document.getElementById('props-container');
    let total=0;
    for(let p of container.children){
        let input=p.querySelector('input'); let amt=Number(input.value); let odds=Number(input.dataset.odds);
        if(amt>0){ total += amt*odds + amt; }
    }
    const payoutDisplay=document.getElementById('total-payout');
    payoutDisplay.textContent=total; payoutDisplay.style.color=total>50?'green':'yellow';
}
document.getElementById('submit-bets').addEventListener('click', async ()=>{
  try {
    const st = window.__appState || {};
    if (!st.bettingOpen) { alert('Betting not open.'); return; }

    const u = auth.currentUser;
    if (!u) { alert('Not signed in.'); return; }

    const username = currentUser;
    const userDocRef = db.collection('users').doc(u.uid);

    // Collect bet inputs from the UI
    const container = document.getElementById('props-container');
    const player = document.getElementById('player-select').value;

    // Build an array of {propName, odds, amount} from the inputs
    const entries = [];
    for (let node of container.children) {
      const label = node.querySelector('span')?.textContent || '';
      const input = node.querySelector('input');
      if (!input) continue;
      const amt = Number(input.value || 0);
      const odds = Number(input.dataset.odds || 0);
      if (amt > 0 && odds > 0) {
        entries.push({
          propName: label.split(' (')[0], // "Score (4x)" -> "Score"
          odds,
          amount: amt
        });
      }
    }

    if (entries.length === 0) {
      alert('Enter at least one bet amount.');
      return;
    }

    // Sum up total to deduct
    const totalStake = entries.reduce((s, e) => s + e.amount, 0);

    // Do everything atomically
    await db.runTransaction(async (tx) => {
      // 1) Check app state
      const stateSnap = await tx.get(stateRef);
      if (!stateSnap.exists) throw new Error('App state missing.');
      const state = stateSnap.data() || {};
      const currentMatch = Number(state.currentMatch || 0);
      if (!state.bettingOpen) throw new Error('Betting is not open.');

      // 2) Check user funds
      const userSnap = await tx.get(userDocRef);
      if (!userSnap.exists) throw new Error('User profile missing.');
      const d = userSnap.data() || {};
      const avail = Number(d.availableCoins || 0);
      if (totalStake > avail) throw new Error('Insufficient available coins.');

      // 3) Create bet docs under the current match
      const betsCol = db.collection('matches').doc(String(currentMatch)).collection('bets');
      const now = firebase.firestore.FieldValue.serverTimestamp();

      entries.forEach((e) => {
        const betRef = betsCol.doc(); // auto id
        tx.set(betRef, {
          uid: u.uid,
          username: username,
          match: currentMatch,
          player: player,
          prop: e.propName,
          odds: e.odds,
          amount: e.amount,
          resolved: false,
          won: false,
          createdAt: now
        });
      });

      // 4) Deduct availableCoins
      tx.update(userDocRef, {
        availableCoins: avail - totalStake
      });
    });

    // Clear inputs + refresh UI
    for (let node of document.getElementById('props-container').children) {
      const input = node.querySelector('input');
      if (input) input.value = '';
    }
    updatePotentialPayout();
    alert('Bets placed!');

  } catch (err) {
    alert('Place bets failed: ' + (err && err.message ? err.message : String(err)));
  }
});
// ------------------ ADMIN BET CONTROL ------------------
document.getElementById('open-bets').addEventListener('click', async ()=>{
  if (!currentUser || !isAdmin()) return;

  try {
    // 1) Flip app state (increment match, open betting, ensure match not active)
    await stateRef.set({
      bettingOpen: true,
      matchActive: false,
      currentMatch: firebase.firestore.FieldValue.increment(1)
    }, { merge: true });

    // 2) Give coins to all non-admin users (batch for speed)
    const usersSnap = await db.collection('users').get();
    const batch = db.batch();
    usersSnap.forEach(doc => {
      const d = doc.data() || {};
      const isAdmin = d.roles && d.roles.admin === true;
      if (isAdmin) return;

      const total = typeof d.coins === 'number' ? d.coins : 100;
      const avail = typeof d.availableCoins === 'number' ? d.availableCoins : 0;

      // same logic you had locally:
      const grant = Math.min(10, total);       // cannot grant more than they have
      const newTotal = total - grant;
      const newAvail = avail + grant;

      batch.set(doc.ref, {
        coins: newTotal,
        availableCoins: newAvail,
        voted: false // optional: clears voted for new match, like before
      }, { merge: true });
    });
    await batch.commit();

    alert('Betting opened and balances granted.');
  } catch (e) {
    alert('Open betting failed: ' + (e && e.code ? e.code + ' - ' : '') + (e && e.message ? e.message : e));
  }
});
  // We will handle coins later when we move coins to Firestore.
document.getElementById('close-bets').addEventListener('click', async ()=>{
  if (!currentUser || !isAdmin()) return;

  try {
    // 1) Flip app state
    await stateRef.set({ bettingOpen: false }, { merge: true });

    // 2) Zero availableCoins for all non-admins (only if needed) and count how many were changed
    const usersSnap = await db.collection('users').get();
    const batch = db.batch();
    let touched = 0;

    usersSnap.forEach(doc => {
  const d = doc.data() || {};
  const isA = d.roles && d.roles.admin === true; // skip admins
  if (isA) return;

  const currentAvail = Number(d.availableCoins || 0);
  if (currentAvail !== 0) {
    batch.set(doc.ref, { availableCoins: 0 }, { merge: true });
    touched++;
  }
});

    if (touched > 0) {
      await batch.commit();
    }

    alert('Betting closed. Zeroed availableCoins for ' + touched + ' user(s).');
  } catch (e) {
    alert('Close betting failed: ' + (e && e.code ? e.code + ' - ' : '') + (e && e.message ? e.message : e));
  }
});
document.getElementById('start-match').addEventListener('click', async ()=>{
  if (!currentUser || !isAdmin()) return;
  try {
    await stateRef.update({ matchActive: true });
    reviewBetsForAdminFS(); // <-- Firestore version (REPLACED LINE)
    alert('Match started.');
  } catch (e) {
    alert('Start match failed: ' + (e && e.message ? e.message : e));
  }
});
document.getElementById('end-match').addEventListener('click', async ()=>{
  if (!currentUser || !isAdmin()) return;

  try {
    // 1) Mark match as inactive first
    await stateRef.update({ matchActive: false });

    // 2) Resolve Firestore listener for admin cards
    if (adminBetsUnsub) { adminBetsUnsub(); adminBetsUnsub = null; }

    // 3) Compute MVP from votes in this match + write results + update totals
    const st = window.__appState || {};
    const matchNum = Number(st.currentMatch || 0);
    if (!matchNum) throw new Error('No match number to close.');

    await computeMvpAndPersistFS(matchNum);

    alert('Match ended & MVP tallied.');
    updateLeaderboards(); // refresh MVP UI
  } catch (e) {
    alert('End match failed: ' + (e && e.message ? e.message : e));
  }
});
async function computeMvpAndPersistFS(matchNum){
  // read all votes for the match
  const votesSnap = await db.collection('matches').doc(String(matchNum)).collection('votes').get();

  // tally points
  const tally = {}; // player -> points
  const results = []; // for pretty match card history
  votesSnap.forEach(doc=>{
    const v = doc.data() || {};
    if (v.first)  tally[v.first]  = (tally[v.first]  || 0) + 5;
    if (v.second) tally[v.second] = (tally[v.second] || 0) + 3;
    if (v.third)  tally[v.third]  = (tally[v.third]  || 0) + 2;
  });

  // build per-player result array (sorted desc points)
  const rows = Object.keys(tally).map(player=>({ player, points: tally[player] }));
  rows.sort((a,b)=>b.points - a.points);

  // decorate with place medals for top 3 (optional / keeps your UI style)
  rows.forEach((r, i)=>{
    r.place = (i===0?'1st':i===1?'2nd':i===2?'3rd':''); // empty for >3, still shows points
  });

  // write match result doc
  await db.collection('matches').doc(String(matchNum)).collection('mvpResult').doc('summary').set({
    match: matchNum,
    results: rows,
    createdAt: firebase.firestore.FieldValue.serverTimestamp()
  }, { merge: true });

  // update global mvpScores (increment per player)
  const batch = db.batch();
  rows.forEach(r=>{
    const ref = db.collection('mvpScores').doc(r.player);
    batch.set(ref, { points: firebase.firestore.FieldValue.increment(r.points) }, { merge: true });
  });
  await batch.commit();
}

// ------------------ REVIEW & RESOLVE BETS ------------------
// ------------------ REVIEW & RESOLVE BETS ------------------
function reviewBetsForAdminFS(){
  const resolveDiv = document.getElementById('resolve-bets');
  if (!resolveDiv) return;

  resolveDiv.innerHTML = "<h3>Resolve Bets (Firestore)</h3>";

  // Only show for admins
  const userIsAdmin = isAdmin();
  if (!userIsAdmin) {
    const p = document.createElement('div');
    p.textContent = 'Admin only.';
    resolveDiv.appendChild(p);
    return;
  }

  // Need a current match number
  const st = window.__appState || {};
  const matchNum = Number(st.currentMatch || 0);
  if (!matchNum) {
    const p = document.createElement('div');
    p.textContent = 'No active match yet.';
    resolveDiv.appendChild(p);
    if (adminBetsUnsub) { adminBetsUnsub(); adminBetsUnsub = null; }
    return;
  }

  // Re-subscribe fresh each time
  if (adminBetsUnsub) { adminBetsUnsub(); adminBetsUnsub = null; }

  const q = db.collection('matches')
              .doc(String(matchNum))
              .collection('bets')
              .where('resolved', '==', false);

  adminBetsUnsub = q.onSnapshot((qsnap) => {
    resolveDiv.innerHTML = "<h3>Resolve Bets (Firestore)</h3>";

    // Group by (player, prop, odds)
    const groups = {};
    qsnap.forEach(doc => {
      const d = doc.data();
      const key = `${d.player}||${d.prop}||${d.odds}`;
      if (!groups[key]) groups[key] = [];
      groups[key].push({ id: doc.id, ...d });
    });

    const keys = Object.keys(groups);
    if (keys.length === 0) {
      const p = document.createElement('div');
      p.textContent = 'No unresolved bets.';
      resolveDiv.appendChild(p);
      return;
    }

    keys.forEach(key => {
      const betGroup = groups[key];
      const sample = betGroup[0];

      const div = document.createElement('div');
      div.className = 'admin-bet-card';

      const totalStake = betGroup.reduce((sum, b) => sum + Number(b.amount || 0), 0);
      div.innerHTML = `${sample.player} - ${sample.prop} | Odds: ${sample.odds}x | Bets: ${betGroup.length} | Total Staked: ${totalStake}`;

      const winBtn = document.createElement('button');
      winBtn.textContent = 'Win';
      winBtn.className = 'admin-win-btn';

      const loseBtn = document.createElement('button');
      loseBtn.textContent = 'Lose';
      loseBtn.className = 'admin-lose-btn';

      winBtn.onclick  = () => resolveBetGroupFS(matchNum, betGroup, true,  div);
      loseBtn.onclick = () => resolveBetGroupFS(matchNum, betGroup, false, div);

      div.appendChild(winBtn);
      div.appendChild(loseBtn);
      resolveDiv.appendChild(div);
    });

  }, (err) => {
    const p = document.createElement('div');
    p.style.color = 'red';
    p.textContent = 'Admin bets listener error: ' + (err && err.message ? err.message : String(err));
    resolveDiv.appendChild(p);
  });
}
async function resolveBetGroupFS(matchNum, betGroup, won, cardEl){
  // Extra guard—admin only
  if (!isAdmin()) return;

  try {
    const batch = db.batch();

    betGroup.forEach(b => {
      const betRef = db.collection('matches')
                       .doc(String(matchNum))
                       .collection('bets')
                       .doc(b.id);

      // Mark resolved
      batch.update(betRef, { resolved: true, won: !!won });

      // If win, pay the user: payout = amt * odds + amt
      if (won) {
        const payout = (Number(b.amount || 0) * Number(b.odds || 0)) + Number(b.amount || 0);
        const userRef = db.collection('users').doc(b.uid);
        batch.update(userRef, { coins: firebase.firestore.FieldValue.increment(payout) });
      }
    });

    await batch.commit();

    if (cardEl) cardEl.remove();
    alert(`Marked ${betGroup.length} bet(s) as ${won ? 'WIN' : 'LOSE'}.`);
  } catch (e) {
    alert('Resolve failed: ' + (e && e.message ? e.message : e));
  }
}

// ------------------ LEADERBOARDS (MVP via Firestore) ------------------
async function updateLeaderboards(){
  // MVP leaderboard totals
  try {
    const tbody = document.getElementById('mvp-leaderboard').querySelector('tbody');
    tbody.innerHTML = '';
    const snap = await db.collection('mvpScores').orderBy('points','desc').get();
    let rank = 1;
    snap.forEach(doc=>{
      const d = doc.data() || {};
      const name = doc.id; // we use player name as doc id
      const pts  = typeof d.points === 'number' ? d.points : 0;
      const icon = rank===1?'🥇':rank===2?'🥈':rank===3?'🥉':rank<7?'🪨':'🍆';
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${rank} ${icon}</td><td>${name}</td><td>${pts}</td>`;
      tbody.appendChild(tr);
      rank++;
    });
  } catch (e) {
    const tbody = document.getElementById('mvp-leaderboard').querySelector('tbody');
    const tr = document.createElement('tr');
    tr.innerHTML = `<td colspan="3" style="color:red;">MVP leaderboard failed: ${e && e.message ? e.message : e}</td>`;
    tbody.appendChild(tr);
  }

  // MVP history per match
  try {
    const wrap = document.getElementById('mvp-history');
    wrap.innerHTML = '';

    // Grab latest ~20 match results (you can tweak)
    // We don’t have an index field besides matchId; we’ll read a handful by id if needed.
    // Simpler: read all mvpResult docs (small scale).
    const qs = await db.collectionGroup('mvpResult').get();

    // Group by match, sort desc by numeric match
    const results = [];
    qs.forEach(doc=>{
      const path = doc.ref.parent.parent; // .../matches/{matchId}
      const matchNum = path ? Number(path.id) : 0;
      results.push({ match: matchNum, ...doc.data() });
    });
    results.sort((a,b)=>b.match - a.match);

    results.forEach(r=>{
      const div = document.createElement('div');
      div.className = 'mvp-card';
      div.innerHTML = `<strong>Match ${r.match}</strong>`;

      (r.results || []).forEach(item=>{
        // item: { player, points, place }
        const emoji = item.points===5?'🥇':item.points===3?'🥈':item.points===2?'🥉':(item.points>=1 && item.points<=7?'🪨':'🍆');
        const line = document.createElement('div');
        line.className = 'result';
        line.textContent = `${emoji} ${item.place}: ${item.player} (+${item.points})`;
        div.appendChild(line);
      });

      wrap.appendChild(div);
    });

  } catch (e) {
    const wrap = document.getElementById('mvp-history');
    const err = document.createElement('div');
    err.style.color = 'red';
    err.textContent = 'MVP history load failed: ' + (e && e.message ? e.message : e);
    wrap.appendChild(err);
  }

  // NOTE: coin leaderboard is handled elsewhere (renderCoinLeaderboardFS)
}

// ------------------ HISTORY ------------------

// ------------------ ADMIN PROP MANAGEMENT ------------------
function populatePropAdmin(){
  const sel = document.getElementById('prop-player');
  sel.innerHTML = "";

  (propEntities || []).forEach(p=>{
    const opt = document.createElement("option");
    opt.value = p;
    opt.text  = p;
    sel.appendChild(opt);
  });

  // Render lists
  renderPropsList();
  renderEntityList();

  // --- ADD ENTITY MANAGEMENT CONTROLS (Add Player) ---
  let entityContainer = document.getElementById('prop-entity-container');
  if (!entityContainer) {
    entityContainer = document.createElement('div');
    entityContainer.id = 'prop-entity-container';
    entityContainer.style.margin = "10px 0";

    const input = document.createElement('input');
    input.type = 'text';
    input.id = 'new-entity';
    input.placeholder = 'Enter new player';
    input.style.margin = "0 0 10px 0";
    input.style.padding = "6px";
    input.style.width = "100%";

    const addBtn = document.createElement('button');
    addBtn.textContent = 'Add Player';
    addBtn.style.marginTop = "6px";

    addBtn.onclick = async ()=>{
      if (!isAdmin()) return;
      const name = (document.getElementById('new-entity').value || '').trim();
      if (!name) { alert('Enter a player name'); return; }
      if ((propEntities || []).includes(name)) { alert('Player already exists'); return; }

      try {
        // 1) Add to players list
        await db.collection('config').doc('players').set({
          list: firebase.firestore.FieldValue.arrayUnion(name)
        }, { merge: true });

        // 2) Default props doc for the player
        await db.collection('config')
          .doc('propsTemplate')
          .collection('byPlayer')
          .doc(name)
          .set({
            items: [
              { name:'Score',    odds:4 },
              { name:'Assist',   odds:3 },
              { name:'Anything', odds:2 }
            ]
          }, { merge: true });

        document.getElementById('new-entity').value = '';
        alert('Player added.');
        // UI auto-refreshes via attachPlayersListener()
      } catch (e) {
        alert('Add player failed: ' + (e?.message || e));
      }
    };

    entityContainer.appendChild(input);
    entityContainer.appendChild(addBtn);
    sel.parentNode.insertBefore(entityContainer, sel.nextElementSibling);
  }
}
    function renderEntityList(){
  let container = document.getElementById('entity-list');
  if (!container) {
    container = document.createElement('div');
    container.id = 'entity-list';
    container.style.margin = "10px 0";
    document.getElementById('prop-player').parentNode.appendChild(container);
  }
  container.innerHTML = "";

  (propEntities || []).forEach((playerName)=>{
    const row = document.createElement('div');
    row.style.margin = "6px 0";
    row.textContent = playerName + " ";

    const btn = document.createElement('button');
    btn.textContent = "Remove";
    btn.style.marginLeft = "10px";
    btn.style.padding = "3px 8px";
    btn.style.backgroundColor = "#ff4d4d";
    btn.style.color = "#fff";
    btn.style.border = "none";
    btn.style.borderRadius = "4px";
    btn.style.cursor = "pointer";

    btn.onclick = async ()=>{
      if (!isAdmin()) return;
      if (!confirm(`Remove player "${playerName}" from betting? This also clears their props.`)) return;

      try {
        await db.collection('config').doc('players').set({
          list: firebase.firestore.FieldValue.arrayRemove(playerName)
        }, { merge: true });

        await db.collection('config')
          .doc('propsTemplate')
          .collection('byPlayer')
          .doc(playerName)
          .delete();

        alert('Player removed.');
        // UI auto-refreshes via listeners
      } catch (e) {
        alert('Remove player failed: ' + (e?.message || e));
      }
    };

    row.appendChild(btn);
    container.appendChild(row);
  });
}
function renderPropsList(){
  const container = document.getElementById('props-list');
  if (!container) return;
  container.innerHTML = "";

  const player = document.getElementById('prop-player').value;
  const items = (propsTemplate[player] || []);

  items.forEach((p)=>{
    const div = document.createElement('div');
    div.style.margin = "6px 0";
    div.textContent = `${p.name} (${p.odds}x) `;

    const btn = document.createElement('button');
    btn.textContent = "Remove";
    btn.style.marginLeft = "10px";
    btn.onclick = async ()=>{
      if (!isAdmin()) return;
      if (!confirm(`Remove prop "${p.name}" from ${player}?`)) return;

      try {
        await db.collection('config')
          .doc('propsTemplate')
          .collection('byPlayer')
          .doc(player)
          .set({
            items: firebase.firestore.FieldValue.arrayRemove({ name: p.name, odds: p.odds })
          }, { merge: true });
        // UI auto-updates via props listener
      } catch (e) {
        alert('Remove prop failed: ' + (e?.message || e));
      }
    };

    div.appendChild(btn);
    container.appendChild(div);
  });
}

// Add new prop
document.getElementById('add-prop').addEventListener('click', async ()=>{
  if (!currentUser || !isAdmin()) return;

  const player = document.getElementById('prop-player').value;
  const name = (document.getElementById('new-prop').value || '').trim();
  const odds = parseInt(document.getElementById('new-odds').value, 10);

  if (!player) { alert('Select a player'); return; }
  if (!name || !(odds > 0)) { alert('Enter valid prop name and odds'); return; }

  try {
    await db.collection('config')
      .doc('propsTemplate')
      .collection('byPlayer')
      .doc(player)
      .set({
        items: firebase.firestore.FieldValue.arrayUnion({ name, odds })
      }, { merge: true });

    document.getElementById('new-prop').value = '';
    document.getElementById('new-odds').value = '';
    alert('Prop added.');
    // UI auto-updates via listener
  } catch (e) {
    alert('Add prop failed: ' + (e?.message || e));
  }
});
// ------------------ DELETE USER ------------------
function deleteUser(username){
    if(!currentUser || !isAdmin()) return;
    if(confirm(`Admin, confirm delete ${username}?`)){ delete users[username]; updateLeaderboards(); updateUI(); alert(`${username} deleted`); }
}

// ------------------ CLEAR VOTES ------------------
document.getElementById('clear-votes').addEventListener('click',()=>{
    if(!currentUser || !isAdmin()) return;
    Object.keys(users).forEach(u=>users[u].votesThisMatch={});
    mvpScores={}; mvpHistory=[]; currentMatch=0;
    localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
    localStorage.removeItem('mvpScores'); localStorage.removeItem('mvpHistory'); localStorage.setItem('currentMatch', currentMatch);
    updateLeaderboards(); updateUI(); alert("Votes cleared.");
});
// TEMP — one-time cleanup: set roles.admin=false for any non-admin missing it
document.getElementById('normalize-roles').addEventListener('click', async ()=>{
  // must be admin in your local model
  if (!currentUser || !isAdmin()) {
    alert('Admin only'); 
    return; 
  }

  try {
    const qs = await db.collection('users').get();
    const batch = db.batch();
    let touched = 0;

    qs.forEach(doc => {
      const d = doc.data() || {};
      const isAdmin = d.roles && d.roles.admin === true;

      // If NOT admin and (roles missing OR roles.admin not boolean), set false
      if (!isAdmin) {
        const hasRoles = !!d.roles;
        const hasBool = hasRoles && (typeof d.roles.admin === 'boolean');
        if (!hasBool) {
          batch.set(doc.ref, { roles: { admin: false } }, { merge: true });
          touched++;
        }
      }
    });

    if (touched > 0) {
      await batch.commit();
      alert('Roles normalized on ' + touched + ' user(s).');
    } else {
      alert('No changes needed — everyone already has roles.admin.');
    }
  } catch (e) {
    alert('Normalize failed: ' + (e && e.message ? e.message : e));
  }
});
// TEMP: Promote the current user to admin. Remove after use.
document.getElementById('promote-me').addEventListener('click', async ()=>{
  const u = auth.currentUser;
  if(!u){ alert("Not signed in."); return; }

  // Safety: only allow if the username is exactly 'admin'
  const uname = (u.displayName && u.displayName.trim()) ? u.displayName.trim() : (u.email ? u.email.split("@")[0] : "");
  if (uname !== 'admin') {
    alert("For safety, only the 'admin' user can self-promote here.");
    return;
  }

  try {
    await db.collection('users').doc(u.uid).set({ roles: { admin: true } }, { merge: true });
    // Keep your local flag in sync so the Admin tab shows
    if (!users[uname]) users[uname] = {};
    users[uname].isAdmin = true;
    localStorage.setItem('kickcoinsUsers', JSON.stringify(users));
    updateUI();

    alert("You're now an admin. (Remove this button after confirming.)");
  } catch (e) {
    alert("Failed to promote: " + e.message);
  }
});
// TEMP: Seed config docs with defaults (players, props, MVP players)
document.getElementById('seed-config').addEventListener('click', async ()=>{
  if (!isAdmin()) { alert("Admin only."); return; }

  try {
    const cfg = db.collection('config');

    // Betting roster
    await cfg.doc('players').set({
      list: ["Erick","Yansy","Bernie","Erubial","Samir","Angel","Abel","Alan","Ace"]
    }, { merge: true });

    // MVP roster
    await cfg.doc('mvpPlayers').set({
      list: ["Erick","Yansy","Bernie","Erubial","Samir","Angel","Abel","Alan","Ace"]
    }, { merge: true });

    // Default props
    const defaultProps = [
      { name:'Score', odds:4 },
      { name:'Assist', odds:3 },
      { name:'Anything', odds:2 }
    ];

    for (const p of ["Erick","Yansy","Bernie","Erubial","Samir","Angel","Abel","Alan","Ace"]) {
      await cfg.doc('propsTemplate')
        .collection('byPlayer')
        .doc(p)
        .set({ items: defaultProps }, { merge: true });
    }

    alert("Config seeded with players, MVP list, and default props.");
  } catch (e) {
    alert("Seed config failed: " + (e && e.message ? e.message : e));
  }
});
// TEMP: Reset app state so admin buttons unlock easily
document.getElementById('reset-state').addEventListener('click', async ()=>{
  if (!isAdmin()) { alert("Admin only."); return; }
  try {
    await db.collection('app').doc('state').set({
      bettingOpen: false,
      matchActive: false
      // intentionally NOT changing currentMatch
    }, { merge: true });
    alert("App state reset. (bettingOpen=false, matchActive=false)");
  } catch (e) {
    alert("Reset state failed: " + (e?.message || e));
  }
});
// DEBUG: show what the app thinks right now
document.getElementById('debug-status').addEventListener('click', async ()=>{
  try {
    const u = auth.currentUser;
    const uid = u ? u.uid : '(no user)';
    // what the live listeners currently have
    const meCopy = JSON.stringify(__me, null, 2);
    const appCopy = JSON.stringify(window.__appState || {}, null, 2);

    // fetch fresh from Firestore too (in case listener didn’t attach)
    let userDocData = null;
    let stateDocData = null;
    if (u) {
      const userSnap = await db.collection('users').doc(uid).get();
      userDocData = userSnap.exists ? userSnap.data() : null;
    }
    const stateSnap = await db.collection('app').doc('state').get();
    stateDocData = stateSnap.exists ? stateSnap.data() : null;

    // read current button disabled flags
    const ob = document.getElementById('open-bets');
    const cb = document.getElementById('close-bets');
    const sm = document.getElementById('start-match');
    const em = document.getElementById('end-match');

    const details = [
      `UID: ${uid}`,
      `isAdmin(): ${isAdmin()}`,
      '',
      `__me (listener):\n${meCopy}`,
      '',
      `window.__appState (listener):\n${appCopy}`,
      '',
      `users/${uid} (fresh read):\n${JSON.stringify(userDocData, null, 2)}`,
      '',
      `app/state (fresh read):\n${JSON.stringify(stateDocData, null, 2)}`,
      '',
      `Buttons disabled?`,
      `  Open Bets:  ${ob ? ob.disabled : '(missing)'}  <- disabled if !admin OR bettingOpen`,
      `  Close Bets: ${cb ? cb.disabled : '(missing)'}  <- disabled if !admin OR !bettingOpen`,
      `  Start:      ${sm ? sm.disabled : '(missing)'}  <- disabled if !admin OR matchActive OR bettingOpen`,
      `  End:        ${em ? em.disabled : '(missing)'}  <- disabled if !admin OR !matchActive`,
    ].join('\n');

    alert(details);
  } catch (e) {
    alert('Debug failed: ' + (e?.message || e));
  }
});
</script>
</body>
</html>
